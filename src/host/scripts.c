/* Premake's Lua scripts, as static data buffers for release mode builds */
/* DO NOT EDIT - this file is autogenerated - see BUILD.txt */
/* To regenerate this file, run: premake5 embed */ 

const char* builtin_scripts[] = {
	/* _premake_main.lua */
	"local shorthelp     = \"Type 'premake5 --help' for help\"\nlocal versionhelp   = \"premake5 (Premake Build Script Generator) %s\"\n_WORKING_DIR        = os.getcwd()\nfunction _premake_main()\nconfiguration {}\nmath.randomseed(os.time())\ndofileopt(_OPTIONS[\"systemscript\"] or { \"premake5-system.lua\", \"premake-system.lua\" })\nconfiguration {}\nif _ACTION and _ACTION:endswith(\"ng\") then\npremake.warnOnce(_ACTION, \"'%s' has been deprecated; use '%s' instead\", _ACTION, _ACTION:sub(1, -3))\nend\npremake.action.set(_ACTION)\nlocal hasScript = dofileopt(_OPTIONS[\"file\"] or { \"premake5.lua\", \"premake4.lua\" })\nif (_OPTIONS[\"version\"]) then\nprintf(versionhelp, _PREMAKE_VERSION)\nreturn 1\nend\nif (_OPTIONS[\"help\"]) then\npremake.showhelp()\nreturn 1\nend\nif (not _ACTION) then\nprint(shorthelp)\nreturn 1\nend\nif not hasScript then\nerror(\"No Premake script (premake5.lua) found!\", 0)\nend\naction = premake.action.current()\nif not action then\nerror(\"Error: no such action '\" .. _ACTION .. \"'\","
	" 0)\nend\nok, err = premake.option.validate(_OPTIONS)\nif not ok then error(\"Error: \" .. err, 0) end\nprint(\"Building configurations...\")\npremake.solution.bakeall()\npremake.validate()\nprintf(\"Running action '%s'...\", action.trigger)\npremake.action.call(action.trigger)\nprint(\"Done.\")\nreturn 0\nend\n",

	/* base/os.lua */
	"function os.executef(cmd, ...)\ncmd = string.format(cmd, unpack(arg))\nreturn os.execute(cmd)\nend\nlocal function parse_ld_so_conf(conf_file)\nlocal first, last\nlocal dirs = { }\nfor line in io.lines(conf_file) do\nfirst = line:find(\"#\", 1, true)\nif first ~= nil then\nline = line:sub(1, first - 1)\nend\nif line ~= \"\" then\nfirst, last = line:find(\"include%s+\")\nif first ~= nil then\nlocal include_glob = line:sub(last + 1)\nlocal includes = os.matchfiles(include_glob)\nfor _, v in ipairs(includes) do\ndirs = table.join(dirs, parse_ld_so_conf(v))\nend\nelse\ntable.insert(dirs, line)\nend\nend\nend\nreturn dirs\nend\nfunction os.findlib(libname)\nlocal path, formats\nif os.is(\"windows\") then\nformats = { \"%s.dll\", \"%s\" }\npath = os.getenv(\"PATH\")\nelseif os.is(\"haiku\") then\nformats = { \"lib%s.so\", \"%s.so\" }\npath = os.getenv(\"LIBRARY_PATH\")\nelse\nif os.is(\"macosx\") then\nformats = { \"lib%s.dylib\", \"%s.dylib\" }\npath = os.getenv(\"DYLD_LIBRARY_PATH\")\nelse\nformats = { \"lib%s.so"
	"\", \"%s.so\" }\npath = os.getenv(\"LD_LIBRARY_PATH\") or \"\"\nfor _, v in ipairs(parse_ld_so_conf(\"/etc/ld.so.conf\")) do\npath = path .. \":\" .. v\nend\nend\ntable.insert(formats, \"%s\")\npath = path or \"\"\nif os.is64bit() then\npath = path .. \":/lib64:/usr/lib64/:usr/local/lib64\"\nend\npath = path .. \":/lib:/usr/lib:/usr/local/lib\"\nend\nfor _, fmt in ipairs(formats) do\nlocal name = string.format(fmt, libname)\nlocal result = os.pathsearch(name, path)\nif result then return result end\nend\nend\nfunction os.get()\nreturn _OPTIONS.os or _OS\nend\nfunction os.is(id)\nreturn (os.get():lower() == id:lower())\nend\nlocal _64BitHostTypes = {\n\"x86_64\",\n\"ia64\",\n\"amd64\",\n\"ppc64\",\n\"powerpc64\",\n\"sparc64\"\n}\nfunction os.is64bit()\nif (os._is64bit()) then\nreturn true\nend\nlocal arch\nif _OS == \"windows\" then\narch = os.getenv(\"PROCESSOR_ARCHITECTURE\")\nelseif _OS == \"macosx\" then\narch = os.outputof(\"echo $HOSTTYPE\")\nelse\narch = os.outputof(\"uname -m\")\nend\narch = arch:lower("
	")\nfor _, hosttype in ipairs(_64BitHostTypes) do\nif arch:find(hosttype) then\nreturn true\nend\nend\nreturn false\nend\nlocal function domatch(result, mask, wantfiles)\nif mask:startswith(\"./\") then\nmask = mask:sub(3)\nend\nlocal basedir = mask\nlocal starpos = mask:find(\"%*\")\nif starpos then\nbasedir = basedir:sub(1, starpos - 1)\nend\nbasedir = path.getdirectory(basedir)\nif (basedir == \".\") then basedir = \"\" end\nlocal recurse = mask:find(\"**\", nil, true)\nmask = path.wildcards(mask)\nlocal function matchwalker(basedir)\nlocal wildcard = path.join(basedir, \"*\")\nlocal m = os.matchstart(wildcard)\nwhile (os.matchnext(m)) do\nlocal isfile = os.matchisfile(m)\nif ((wantfiles and isfile) or (not wantfiles and not isfile)) then\nlocal fname = path.join(basedir, os.matchname(m))\nif fname:match(mask) == fname then\ntable.insert(result, fname)\nend\nend\nend\nos.matchdone(m)\nif recurse then\nm = os.matchstart(wildcard)\nwhile (os.matchnext(m)) do\nif not os.matchisfile(m) then\nlocal dirname = os.m"
	"atchname(m)\nmatchwalker(path.join(basedir, dirname))\nend\nend\nos.matchdone(m)\nend\nend\nmatchwalker(basedir)\nend\nfunction os.matchdirs(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, false)\nend\nreturn result\nend\nfunction os.matchfiles(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, true)\nend\nreturn result\nend\nlocal builtin_mkdir = os.mkdir\nfunction os.mkdir(p)\nlocal dir = iif(p:startswith(\"/\"), \"/\", \"\")\nfor part in p:gmatch(\"[^/]+\") do\ndir = dir .. part\nif (part ~= \"\" and not path.isabsolute(part) and not os.isdir(dir)) then\nlocal ok, err = builtin_mkdir(dir)\nif (not ok) then\nreturn nil, err\nend\nend\ndir = dir .. \"/\"\nend\nreturn true\nend\nfunction os.outputof(cmd)\nlocal pipe = io.popen(cmd)\nlocal result = pipe:read('*a')\npipe:close()\nreturn result\nend\nlocal builtin_remove = os.remove\nfunction os.remove(f)\nif type(f) == \"string\" then\nlocal p = os.matchfiles(f)\nfor _, v in pairs(p) do\nlocal ok, err = "
	"builtin_remove(v)\nif not ok then\nreturn ok, err\nend\nend\nelseif type(f) == \"table\" then\nfor _, v in pairs(f) do\nlocal ok, err = os.remove(v)\nif not ok then\nreturn ok, err\nend\nend\nend\nend\nlocal builtin_rmdir = os.rmdir\nfunction os.rmdir(p)\nlocal dirs = os.matchdirs(p .. \"/*\")\nfor _, dname in ipairs(dirs) do\nos.rmdir(dname)\nend\nlocal files = os.matchfiles(p .. \"/*\")\nfor _, fname in ipairs(files) do\nos.remove(fname)\nend\nbuiltin_rmdir(p)\nend\nos._uuids = {}\nlocal builtin_uuid = os.uuid\nfunction os.uuid(name)\nlocal id = builtin_uuid(name)\nif name then\nif os._uuids[id] and os._uuids[id] ~= name then\npremake.warnOnce(id, \"UUID clash between %s and %s\", os._uuids[id], name)\nend\nos._uuids[id] = name\nend\nreturn id\nend\n",

	/* base/path.lua */
	"function path.appendextension(p, ext)\nif not ext or ext == \"\" then\nreturn p\nend\nlocal endquote\nif p:endswith('\"') then\np = p:sub(1, -2)\nendquote = '\"'\nend\nif not p:endswith(ext) then\np = p .. ext\nend\nif endquote then\np = p .. endquote\nend\nreturn p\nend\nfunction path.getbasename(p)\nlocal name = path.getname(p)\nlocal i = name:findlast(\".\", true)\nif (i) then\nreturn name:sub(1, i - 1)\nelse\nreturn name\nend\nend\nfunction path.getdirectory(p)\nlocal i = p:findlast(\"/\", true)\nif (i) then\nif i > 1 then i = i - 1 end\nreturn p:sub(1, i)\nelse\nreturn \".\"\nend\nend\nfunction path.getdrive(p)\nlocal ch1 = p:sub(1,1)\nlocal ch2 = p:sub(2,2)\nif ch2 == \":\" then\nreturn ch1\nend\nend\nfunction path.getextension(p)\nlocal i = p:findlast(\".\", true)\nif (i) then\nreturn p:sub(i)\nelse\nreturn \"\"\nend\nend\nfunction path.getname(p)\nlocal i = p:findlast(\"[/\\\\]\")\nif (i) then\nreturn p:sub(i + 1)\nelse\nreturn p\nend\nend\nfunction path.hasextension(fname, extensions)\nlocal fext = pa"
	"th.getextension(fname):lower()\nif type(extensions) == \"table\" then\nfor _, extension in pairs(extensions) do\nif fext == extension then\nreturn true\nend\nend\nreturn false\nelse\nreturn (fext == extensions)\nend\nend\nfunction path.iscfile(fname)\nreturn path.hasextension(fname, { \".c\", \".s\", \".m\" })\nend\nfunction path.iscppfile(fname)\nreturn path.hasextension(fname, { \".cc\", \".cpp\", \".cxx\", \".c\", \".s\", \".m\", \".mm\" })\nend\nfunction path.iscppheader(fname)\nreturn path.hasextension(fname, { \".h\", \".hh\", \".hpp\", \".hxx\" })\nend\nfunction path.isframework(fname)\nreturn path.hasextension(fname, \".framework\")\nend\nfunction path.isobjectfile(fname)\nreturn path.hasextension(fname, { \".o\", \".obj\" })\nend\nfunction path.isresourcefile(fname)\nreturn path.hasextension(fname, \".rc\")\nend\nfunction path.rebase(p, oldbase, newbase)\np = path.getabsolute(path.join(oldbase, p))\np = path.getrelative(newbase, p)\nreturn p\nend\nfunction path.wildcards(pattern)\npattern = pattern:gs"
	"ub(\"([%+%.%-%^%$%(%)%%])\", \"%%%1\")\npattern = pattern:gsub(\"%*%*\", \"\\001\")\npattern = pattern:gsub(\"%*\", \"\\002\")\npattern = pattern:gsub(\"\\001\", \".*\")\npattern = pattern:gsub(\"\\002\", \"[^/]*\")\nreturn pattern\nend\n",

	/* base/string.lua */
	"function string.contains(s, match)\nreturn string.find(s, match, 1, true) ~= nil\nend\nfunction string.explode(s, pattern, plain)\nif (pattern == '') then return false end\nlocal pos = 0\nlocal arr = { }\nfor st,sp in function() return s:find(pattern, pos, plain) end do\ntable.insert(arr, s:sub(pos, st-1))\npos = sp + 1\nend\ntable.insert(arr, s:sub(pos))\nreturn arr\nend\nfunction string.findlast(s, pattern, plain)\nlocal curr = 0\nrepeat\nlocal next = s:find(pattern, curr + 1, plain)\nif (next) then curr = next end\nuntil (not next)\nif (curr > 0) then\nreturn curr\nend\nend\nfunction string.lines(s)\nlocal trailing, n = s:gsub('.-\\n', '')\nif #trailing > 0 then\nn = n + 1\nend\nreturn n\nend\nfunction string.startswith(haystack, needle)\nreturn (haystack:find(needle, 1, true) == 1)\nend\n",

	/* base/table.lua */
	"function table.arraycopy(object)\nlocal result = {}\nfor i, value in ipairs(object) do\nresult[i] = value\nend\nreturn result\nend\nfunction table.contains(t, value)\nfor _,v in pairs(t) do\nif (v == value) then\nreturn true\nend\nend\nreturn false\nend\nfunction table.deepcopy(object)\nlocal seen = {}\nlocal function copy(object)\nif type(object) ~= \"table\" then\nreturn object\nelseif seen[object] then\nreturn seen[object]\nend\nlocal clone = {}\nseen[object] = clone\nfor key, value in pairs(object) do\nclone[key] = copy(value)\nend\nreturn clone\nend\nreturn copy(object)\nend\nfunction table.extract(arr, fname)\nlocal result = { }\nfor _,v in ipairs(arr) do\ntable.insert(result, v[fname])\nend\nreturn result\nend\nfunction table.flatten(arr)\nlocal result = {}\nlocal function flatten(arr)\nlocal n = #arr\nfor i = 1, n do\nlocal v = arr[i]\nif type(v) == \"table\" then\nflatten(v)\nelseif v then\ntable.insert(result, v)\nend\nend\nend\nflatten(arr)\nreturn result\nend\nfunction table.foreachi(arr, func)\nif"
	" arr then\nif type(arr) == \"string\" then arr = { arr } end\nlocal n = #arr\nfor i = 1, n do\nlocal v = arr[i]\nif v then\nfunc(v)\nend\nend\nend\nend\nfunction table.fold(list1, list2)\nlocal result = {}\nfor _, item1 in ipairs(list1 or {}) do\nif list2 and #list2 > 0 then\nfor _, item2 in ipairs(list2) do\ntable.insert(result, { item1, item2 })\nend\nelse\ntable.insert(result, { item1 })\nend\nend\nreturn result\nend\nfunction table.implode(arr, before, after, between)\nlocal result = \"\"\nfor _,v in ipairs(arr) do\nif (result ~= \"\" and between) then\nresult = result .. between\nend\nresult = result .. before .. v .. after\nend\nreturn result\nend\nfunction table.indexof(tbl, obj)\nlocal count = #tbl\nfor i = 1, count do\nif tbl[i] == obj then\nreturn i\nend\nend\nend\nfunction table.insertafter(tbl, after, value)\nlocal i = table.indexof(tbl, after)\nif i then\ntable.insert(tbl, i + 1, value)\nelse\ntable.insert(tbl, value)\nend\nend\nfunction table.insertflat(tbl, values)\nif type(values) == \"table\" "
	"then\nfor _, value in ipairs(values) do\ntable.insertflat(tbl, value)\nend\nelse\ntable.insert(tbl, values)\nend\nend\nfunction table.isempty(t)\nreturn next(t) == nil\nend\nfunction table.join(...)\nlocal result = { }\nfor _,t in ipairs(arg) do\nif type(t) == \"table\" then\nfor _,v in ipairs(t) do\ntable.insert(result, v)\nend\nelse\ntable.insert(result, t)\nend\nend\nreturn result\nend\nfunction table.keys(tbl)\nlocal keys = {}\nfor k, _ in pairs(tbl) do\ntable.insert(keys, k)\nend\nreturn keys\nend\nfunction table.merge(...)\nlocal result = {}\nfor _,t in ipairs(arg) do\nif type(t) == \"table\" then\nfor k,v in pairs(t) do\nif type(result[k]) == \"table\" and type(v) == \"table\" then\nresult[k] = table.merge(result[k], v)\nelse\nresult[k] = v\nend\nend\nelse\nerror(\"invalid value\")\nend\nend\nreturn result\nend\nfunction table.translate(arr, translation)\nlocal result = { }\nfor _, value in ipairs(arr) do\nlocal tvalue\nif type(translation) == \"function\" then\ntvalue = translation(value)\nelse\ntvalue"
	" = translation[value]\nend\nif (tvalue) then\ntable.insert(result, tvalue)\nend\nend\nreturn result\nend\n",

	/* base/io.lua */
	"function io.capture(fn)\nlocal old = io._captured\nio._captured = {}\nfn()\nlocal captured = io.captured()\nio._captured = old\nio._captured_string = nil\nreturn captured\nend\nfunction io.captured()\nif io._captured then\nif not io._captured_string then\nio._captured_string = table.concat(io._captured, io.eol)\nend\nreturn io._captured_string\nend\nend\nlocal builtin_open = io.open\nfunction io.open(fname, mode)\nif (mode) then\nif (mode:find(\"w\")) then\nlocal dir = path.getdirectory(fname)\nok, err = os.mkdir(dir)\nif (not ok) then\nerror(err, 0)\nend\nend\nend\nreturn builtin_open(fname, mode)\nend\nfunction io.printf(msg, ...)\nif type(msg) == \"number\" then\nlocal str, fmt, x = unpack(arg)\ns = string.rep(io.indent or \"\\t\", msg) .. string.format(unpack(arg))\nelse\ns = string.format(msg, unpack(arg))\nend\nif not io._captured then\nio.write(s)\nelse\ntable.insert(io._captured, s)\nio._captured_string = nil\nend\nend\nfunction io.utf8()\nio.write('\\239\\187\\191')\nend\nfunction _p(msg, ...)\nio.pri"
	"ntf(msg, unpack(arg))\nif not io._captured then\nio.write(io.eol or \"\\n\")\nend\nend\nfunction _x(msg, ...)\nfor i = 2, #arg do\narg[i] = premake.esc(arg[i])\nend\n_p(msg, unpack(arg))\nend\n",

	/* base/globals.lua */
	"premake = {}\npremake.tools = {}\npremake.platforms =\n{\nNative =\n{\ncfgsuffix       = \"\",\n},\nx32 =\n{\ncfgsuffix       = \"32\",\n},\nx64 =\n{\ncfgsuffix       = \"64\",\n},\nUniversal =\n{\ncfgsuffix       = \"univ\",\n},\nUniversal32 =\n{\ncfgsuffix       = \"univ32\",\n},\nUniversal64 =\n{\ncfgsuffix       = \"univ64\",\n},\nPS3 =\n{\ncfgsuffix       = \"ps3\",\niscrosscompiler = true,\nnosharedlibs    = true,\nnamestyle       = \"PS3\",\n},\nWiiDev =\n{\ncfgsuffix       = \"wii\",\niscrosscompiler = true,\nnamestyle       = \"PS3\",\n},\nXbox360 =\n{\ncfgsuffix       = \"xbox360\",\niscrosscompiler = true,\nnamestyle       = \"windows\",\n},\n}\nlocal function locate(...)\nfor i = 1, select(\"#\",...) do\nlocal fname = select(i,...)\nif os.isfile(fname) then\nreturn fname\nend\nlocal dir = os.pathsearch(fname, _OPTIONS[\"scripts\"], os.getenv(\"PREMAKE_PATH\"))\nif dir then\nreturn path.join(dir, fname)\nend\nend\nend\nlocal builtin_dofile = dofile\nfunction dofile(fname)\nlocal oldcwd = os.getcwd()"
	"\nlocal oldfile = _SCRIPT\nfname = locate(fname) or fname\n_SCRIPT = path.getabsolute(fname)\nlocal newcwd = path.getdirectory(_SCRIPT)\nos.chdir(newcwd)\nlocal a, b, c, d, e, f = builtin_dofile(_SCRIPT)\n_SCRIPT = oldfile\nos.chdir(oldcwd)\nreturn a, b, c, d, e, f\nend\nfunction dofileopt(fname)\nif type(fname) == \"string\" then fname = {fname} end\nfor i = 1, #fname do\nlocal found = locate(fname[i])\nif found then\ndofile(found)\nreturn true\nend\nend\nend\nfunction iif(expr, trueval, falseval)\nif (expr) then\nreturn trueval\nelse\nreturn falseval\nend\nend\nio._includedFiles = {}\nfunction include(fname)\nlocal found = locate(fname)\nif not found then\nfound = locate(path.join(fname, \"premake5.lua\"))\nend\nif not found then\nfound = locate(path.join(fname, \"premake4.lua\"))\nend\nfname = path.getabsolute(found or fname)\nif not io._includedFiles[fname] then\nio._includedFiles[fname] = true\ndofile(fname)\nend\nend\nfunction printf(msg, ...)\nprint(string.format(msg, unpack(arg)))\nend\nlocal builtin_t"
	"ype = type\nfunction type(t)\nlocal mt = getmetatable(t)\nif (mt) then\nif (mt.__type) then\nreturn mt.__type\nend\nend\nreturn builtin_type(t)\nend\n",

	/* base/action.lua */
	"premake.action = { }\npremake.action.list = { }\nfunction premake.action.add(a)\nlocal missing\nfor _, field in ipairs({\"description\", \"trigger\"}) do\nif (not a[field]) then\nmissing = field\nend\nend\nif (missing) then\nerror(\"action needs a \" .. missing, 3)\nend\npremake.action.list[a.trigger] = a\nend\nfunction premake.action.call(name)\nlocal a = premake.action.list[name]\nif _ACTION:endswith(\"ng\") then\n_ACTION = _ACTION:sub(1, -3)\nend\nfor sln in premake.solution.each() do\nif a.onsolution then\na.onsolution(sln)\nend\nfor prj in premake.solution.eachproject(sln) do\nif a.onproject and not prj.external then\na.onproject(prj)\nend\nend\nend\nif a.execute then\na.execute()\nend\nend\nfunction premake.action.current()\nreturn premake.action.get(_ACTION)\nend\nfunction premake.action.get(name)\nif name and name:endswith(\"ng\") then\nname = name:sub(1, -3)\nend\nreturn premake.action.list[name]\nend\nfunction premake.action.each()\nlocal keys = { }\nfor _, action in pairs(premake.action.list) do\nta"
	"ble.insert(keys, action.trigger)\nend\ntable.sort(keys)\nlocal i = 0\nreturn function()\ni = i + 1\nreturn premake.action.list[keys[i]]\nend\nend\nfunction premake.action.set(name)\n_ACTION = name\nlocal action = premake.action.get(name)\nif action then\n_OS = action.os or _OS\nend\nend\nfunction premake.action.supports(action, feature)\nif not action then\nreturn false\nend\nif action.valid_languages then\nif table.contains(action.valid_languages, feature) then\nreturn true\nend\nend\nif action.valid_kinds then\nif table.contains(action.valid_kinds, feature) then\nreturn true\nend\nend\nreturn false\nend\nfunction premake.action.supportsconfig(action, cfg)\nif not action then\nreturn false\nend\nif action.supportsconfig then\nreturn action.supportsconfig(cfg)\nend\nreturn true\nend\n",

	/* base/criteria.lua */
	"premake.criteria = {}\nlocal criteria = premake.criteria\nfunction criteria.new(terms)\nterms = table.flatten(terms)\nfor i, term in ipairs(terms) do\nterms[i] = term:lower()\nend\nlocal patterns = {}\nfor _, term in ipairs(terms) do\nlocal pattern = path.wildcards(term)\ntable.insert(patterns, pattern)\nend\nlocal crit = {}\ncrit.terms = terms\ncrit.patterns = patterns\nreturn crit\nend\nfunction criteria.matches(crit, context, filename)\nlocal filematched = false\nif filename then\nfilename = filename:lower()\nend\nfunction testcontext(pattern, negated)\nfor _, part in ipairs(pattern:explode(\" or \")) do\nif part:startswith(\"not \") then\nreturn not testcontext(part:sub(5), true)\nend\nfor _, value in ipairs(context) do\nif value:match(part) == value then\nreturn true\nend\nend\nif filename and not negated and filename:match(part) == filename then\nfilematched = true\nreturn true\nend\nend\nreturn false\nend\nfor _, pattern in ipairs(crit.patterns) do\nif not testcontext(pattern) then\nreturn false\nend\ne"
	"nd\nif filename and not filematched then\nreturn false\nend\nreturn true\nend\n",

	/* base/option.lua */
	"premake.option = {}\npremake.option.list = {}\nfunction premake.option.add(opt)\nlocal missing\nfor _, field in ipairs({ \"description\", \"trigger\" }) do\nif (not opt[field]) then\nmissing = field\nend\nend\nif (missing) then\nerror(\"option needs a \" .. missing, 3)\nend\npremake.option.list[opt.trigger] = opt\nend\nfunction premake.option.get(name)\nreturn premake.option.list[name]\nend\nfunction premake.option.each()\nlocal keys = { }\nfor _, option in pairs(premake.option.list) do\ntable.insert(keys, option.trigger)\nend\ntable.sort(keys)\nlocal i = 0\nreturn function()\ni = i + 1\nreturn premake.option.list[keys[i]]\nend\nend\nfunction premake.option.validate(values)\nfor key, value in pairs(values) do\nlocal opt = premake.option.get(key)\nif (not opt) then\nreturn false, \"invalid option '\" .. key .. \"'\"\nend\nif (opt.value and value == \"\") then\nreturn false, \"no value specified for option '\" .. key .. \"'\"\nend\nif opt.allowed then\nlocal found = false\nfor _, match in ipairs(opt.allowed) do"
	"\nif match[1] == value then\nfound = true\nbreak\nend\nend\nif not found then\nreturn false, string.format(\"invalid value '%s' for option '%s'\", value, key)\nend\nend\nend\nreturn true\nend\n",

	/* base/tree.lua */
	"premake.tree = {}\nlocal tree = premake.tree\nfunction tree.new(n)\nlocal t = {\nname = n,\nchildren = {}\n}\nreturn t\nend\nfunction tree.add(tr, p, extraFields)\nif p == \".\" then\nreturn tr\nend\nlocal parentnode = tree.add(tr, path.getdirectory(p), extraFields)\nlocal childname = path.getname(p)\nlocal childnode = parentnode.children[childname]\nif not childnode or childnode.path ~= p then\nchildnode = tree.insert(parentnode, tree.new(childname))\nchildnode.path = p\nif extraFields then\nfor k,v in pairs(extraFields) do\nchildnode[k] = v\nend\nend\nend\nreturn childnode\nend\nfunction tree.insert(parent, child)\ntable.insert(parent.children, child)\nif child.name then\nparent.children[child.name] = child\nend\nchild.parent = parent\nreturn child\nend\nfunction tree.getlocalpath(node)\nif node.parent.path then\nreturn node.name\nelseif node.cfg then\nreturn node.cfg.name\nelse\nreturn node.path\nend\nend\nfunction tree.hasbranches(tr)\nlocal n = #tr.children\nif n > 0 then\nfor i = 1, n do\nif #tr.children"
	"[i].children > 0 then\nreturn true\nend\nend\nend\nreturn false\nend\nfunction tree.isparent(n, child)\nlocal p = child.parent\nwhile p do\nif p == n then\nreturn true\nend\np = p.parent\nend\nreturn false\nend\nfunction tree.remove(node)\nlocal children = node.parent.children\nfor i = 1, #children do\nif children[i] == node then\ntable.remove(children, i)\nend\nend\nnode.children = {}\nend\nfunction tree.sort(tr, fn)\nif not fn then\nfn = function(a,b) return a.name < b.name end\nend\ntree.traverse(tr, {\nonnode = function(node)\ntable.sort(node.children, fn)\nend\n}, true)\nend\nfunction tree.traverse(t, fn, includeroot, initialdepth)\nlocal donode, dochildren\ndonode = function(node, fn, depth)\nif node.isremoved then\nreturn\nend\nif fn.onnode then\nfn.onnode(node, depth)\nend\nif #node.children > 0 then\nif fn.onbranchenter then\nfn.onbranchenter(node, depth)\nend\nif fn.onbranch then\nfn.onbranch(node, depth)\nend\ndochildren(node, fn, depth + 1)\nif fn.onbranchexit then\nfn.onbranchexit(node, depth)\nen"
	"d\nelse\nif fn.onleaf then\nfn.onleaf(node, depth)\nend\nend\nend\ndochildren = function(parent, fn, depth)\nlocal i = 1\nwhile i <= #parent.children do\nlocal node = parent.children[i]\ndonode(node, fn, depth)\nif node == parent.children[i] then\ni = i + 1\nend\nend\nend\nif not initialdepth then\ninitialdepth = 0\nend\nif includeroot then\ndonode(t, fn, initialdepth)\nelse\ndochildren(t, fn, initialdepth)\nend\nend\nfunction tree.trimroot(tr)\nlocal trimmed\nwhile #tr.children == 1 do\nlocal node = tr.children[1]\nif #node.children == 0 or node.trim == false then\nbreak\nend\ntrimmed = true\nlocal numChildren = #node.children\nfor i = 1, numChildren do\nlocal child = node.children[i]\nchild.parent = node.parent\ntr.children[i] = child\nend\nend\nlocal dotdot\nlocal count = #tr.children\nrepeat\ndotdot = false\nfor i = 1, count do\nlocal node = tr.children[i]\nif node.name == \"..\" and #node.children == 1 then\nlocal child = node.children[1]\nchild.parent = node.parent\ntr.children[i] = child\ntrimmed = true"
	"\ndotdot = true\nend\nend\nuntil not dotdot\nif trimmed then\ntree.traverse(tr, {\nonnode = function(node)\nif node.parent.path then\nnode.path = path.join(node.parent.path, node.name)\nelse\nnode.path = node.name\nend\nend\n}, false)\nend\nend\n",

	/* base/help.lua */
	"function premake.showhelp()\nprintf(\"Premake %s, a build script generator\", _PREMAKE_VERSION)\nprintf(_PREMAKE_COPYRIGHT)\nprintf(\"%s %s\", _VERSION, _COPYRIGHT)\nprintf(\"\")\nprintf(\"Usage: premake5 [options] action [arguments]\")\nprintf(\"\")\nprintf(\"OPTIONS\")\nprintf(\"\")\nfor option in premake.option.each() do\nlocal trigger = option.trigger\nlocal description = option.description\nif (option.value) then trigger = trigger .. \"=\" .. option.value end\nif (option.allowed) then description = description .. \"; one of:\" end\nprintf(\" --%-15s %s\", trigger, description)\nif (option.allowed) then\nfor _, value in ipairs(option.allowed) do\nprintf(\"     %-14s %s\", value[1], value[2])\nend\nend\nprintf(\"\")\nend\nprintf(\"ACTIONS\")\nprintf(\"\")\nfor action in premake.action.each() do\nprintf(\" %-17s %s\", action.trigger, action.description)\nend\nprintf(\"\")\nprintf(\"For additional information, see http://industriousone.com/premake\")\nend\n",

	/* base/configset.lua */
	"premake.configset = {}\nlocal configset = premake.configset\nlocal criteria = premake.criteria\nconfigset._fields = {}\nfunction configset.new(parent)\nlocal cset = {}\ncset._parent = parent or false\ncset._blocks = {}\ncset._current = false\ncset.compiled = false\nsetmetatable(cset, configset.__mt)\nreturn cset\nend\nfunction configset.registerfield(name, behavior)\nconfigset._fields[name] = behavior\nend\nfunction configset.addblock(cset, terms, basedir)\nlocal block = {}\nblock._basedir = basedir\nblock._criteria = criteria.new(terms)\ntable.insert(cset._blocks, block)\ncset._current = block\nreturn block\nend\nfunction configset.addvalue(cset, fieldname, value)\nif not cset._current then\nconfigset.addblock(cset, {})\nend\nlocal current = cset._current\nlocal field = configset._fields[fieldname]\nif field and (field.keyed or field.merge) then\ncurrent[fieldname] = current[fieldname] or {}\ntable.insert(current[fieldname], value)\nelse\ncurrent[fieldname] = value\nend\nend\nfunction configset.removevalues(c"
	"set, fieldname, values)\nlocal current = cset._current\nconfigset.addblock(cset, current._criteria.terms, current._basedir)\nvalues = table.flatten(values)\nfor i, value in ipairs(values) do\nvalues[i] = path.wildcards(value):lower()\nend\ncurrent = cset._current\ncurrent._removes = {}\ncurrent._removes[fieldname] = values\nend\nfunction configset.empty(cset)\nreturn (#cset._blocks == 0)\nend\nlocal function testblock(block, context, filename)\nif block._basedir and filename then\nfilename = path.getrelative(block._basedir, filename)\nend\nreturn criteria.matches(block._criteria, context, filename)\nend\nfunction configset.compile(cset, context, filename)\nlocal result\nif cset._parent then\nresult = configset.compile(cset._parent, context, filename)\nelse\nresult = configset.new()\nend\nfor _, block in ipairs(cset._blocks) do\nif testblock(block, context, filename) then\ntable.insert(result._blocks, block)\nend\nend\nresult.compiled = true\nreturn result\nend\nlocal function merge(a, b)\nif type(b) == \"table"
	"\" then\nfor _, v in ipairs(b) do\nmerge(a, v)\nend\nelse\nif a[b] then\ntable.remove(a, table.indexof(a, b))\nend\ntable.insert(a, b)\na[b] = b\nend\nend\nlocal function fetchassign(cset, fieldname, context, filename)\nlocal n = #cset._blocks\nfor i = n, 1, -1 do\nlocal block = cset._blocks[i]\nif block[fieldname] and (cset.compiled or testblock(block, context, filename)) then\nreturn block[fieldname]\nend\nend\nif cset._parent then\nreturn fetchassign(cset._parent, fieldname, context, filename)\nend\nend\nlocal function fetchkeyed(cset, fieldname, context, filename, mergevalues)\nlocal result = {}\nif cset._parent then\nresult = fetchkeyed(cset._parent, fieldname, context, filename, merge)\nend\nfunction process(values)\nfor k, v in pairs(values) do\nif type(k) == \"number\" then\nprocess(v)\nelseif mergevalues then\nresult[k] = result[k] or {}\nmerge(result[k], v)\nelse\nresult[k] = v\nend\nend\nend\nfor _, block in ipairs(cset._blocks) do\nif cset.compiled or testblock(block, context, filename) then\nlocal"
	" value = block[fieldname]\nif value then\nprocess(value)\nend\nend\nend\nreturn result\nend\nlocal function fetchmerge(cset, fieldname, context, filename)\nlocal result = {}\nif cset._parent then\nresult = fetchmerge(cset._parent, fieldname, context, filename)\nend\nfunction remove(patterns)\nfor _, pattern in ipairs(patterns) do\nlocal i = 1\nwhile i <= #result do\nlocal value = result[i]:lower()\nif value:match(pattern) == value then\nresult[result[i]] = nil\ntable.remove(result, i)\nelse\ni = i + 1\nend\nend\nend\nend\nfor _, block in ipairs(cset._blocks) do\nif cset.compiled or testblock(block, context, filename) then\nif block._removes and block._removes[fieldname] then\nremove(block._removes[fieldname])\nend\nlocal value = block[fieldname]\nif value then\nmerge(result, value)\nend\nend\nend\nreturn result\nend\nfunction configset.fetchvalue(cset, fieldname, context, filename)\nlocal value\nlocal field = configset._fields[fieldname]\nlocal keyed = field and field.keyed\nlocal merge = field and field.merge"
	"\nif keyed then\nvalue = fetchkeyed(cset, fieldname, context, filename, merge)\nelseif merge then\nvalue = fetchmerge(cset, fieldname, context, filename)\nelse\nvalue = fetchassign(cset, fieldname, context, filename)\nif type(value) == \"table\" then\nvalue = table.deepcopy(value)\nend\nend\nreturn value\nend\nconfigset.__mt = {\n__newindex = configset.addvalue,\n__index = function(cset, fieldname)\nreturn configset.fetchvalue(cset, fieldname, cset._current._criteria.terms)\nend\n}\n",

	/* base/context.lua */
	"premake.context = {}\nlocal context = premake.context\nlocal configset = premake.configset\nfunction context.new(cfgset, environ, filename)\nlocal ctx = {}\nctx._cfgset = cfgset\nctx.environ = environ or {}\nctx._filename = { filename } or {}\nctx.terms = {}\nctx._basedir = os.getcwd()\nsetmetatable(ctx, context.__mt)\nreturn ctx\nend\nfunction context.addterms(ctx, terms)\nif terms then\nterms = table.flatten({terms})\nfor _, term in ipairs(terms) do\ntable.insert(ctx.terms, term:lower())\nend\nend\nend\nfunction context.copyterms(ctx, src)\nctx.terms = table.arraycopy(src.terms)\nend\nfunction context.basedir(ctx, basedir)\nctx._basedir = basedir or ctx._basedir\nreturn ctx._basedir\nend\nfunction context.compile(ctx)\nctx._cfgset = configset.compile(ctx._cfgset, ctx.terms, ctx._filename[1])\nend\nfunction context.empty(ctx)\nreturn configset.empty(ctx._cfgset)\nend\nfunction context.fetchvalue(ctx, key)\nlocal value = configset.fetchvalue(ctx._cfgset, key, ctx.terms, ctx._filename[1])\nif value then\nlocal "
	"field = premake.fields[key]\nif field and field.tokens then\nlocal kind = field.kind\nlocal ispath = kind:startswith(\"path\") or kind:startswith(\"file\") or kind:startswith(\"mixed\")\nvalue = premake.detoken.expand(value, ctx.environ, ispath, ctx._basedir)\nend\nctx[key] = value\nend\nreturn value\nend\ncontext.__mt = {\n__index = context.fetchvalue\n}\n",

	/* base/api.lua */
	"premake.api = {}\nlocal api = premake.api\nlocal configset = premake.configset\npremake.fields = {}\napi.scope = {}\nconfigset.root = configset.new()\nlocal root = configset.root\nfunction api.register(field)\nlocal name = field.name\nif not name then\nerror(\"missing name\", 2)\nend\nif _G[name] then\nerror(\"name '\" .. name .. \"' in use\", 2)\nend\nif not api.getsetter(field) then\nerror(\"invalid kind '\" .. field.kind .. \"'\", 2)\nend\npremake.fields[field.name] = field\n_G[name] = function(value)\nreturn api.callback(field, value)\nend\nif api.islistfield(field) and not api.iskeyedfield(field) then\n_G[\"remove\" .. name] = function(value)\nreturn api.remove(field, value)\nend\nend\nconfigset.registerfield(field.name, {\nkeyed = api.iskeyedfield(field),\nmerge = api.islistfield(field),\n})\nend\nfunction api.addAllowed(fieldName, value)\nlocal field = premake.fields[fieldName]\nif not field then\nerror(\"No such field: \" .. fieldName, 2)\nend\nif not field.allowed then\nfield.allowed = {}\nend\nif typ"
	"e(value) == \"table\" then\nfield.allowed = table.join(field.allowed, value)\nelse\ntable.insert(field.allowed, value)\nend\ntable.sort(field.allowed)\nend\nfunction api.deprecateField(name, message, handler)\npremake.fields[name].deprecated = {\nhandler = handler,\nmessage = message\n}\nend\nfunction api.deprecateValue(name, value, message, addHandler, removeHandler)\nif type(value) == \"table\" then\nfor _, v in pairs(value) do\napi.deprecateValue(name, v, message, addHandler, removeHandler)\nend\nelse\nlocal field = premake.fields[name]\nfield.deprecated = field.deprecated or {}\nfield.deprecated[value] = {\nadd = addHandler,\nremove = removeHandler,\nmessage = message\n}\nend\nend\nfunction api.deprecations(value)\nvalue = value:lower()\nif not table.contains({ \"on\", \"off\", \"error\"}, value) then\nerror(\"Invalid value: \" .. value, 2)\nend\napi._deprecations = value:lower()\nend\napi._deprecations = \"on\"\nfunction api.gettarget(scope)\nlocal target\nif scope == \"project\" then\ntarget = api.scope."
	"project or api.scope.solution or api.scope.root\nelse\ntarget = api.scope.configuration or api.scope.root\nend\nreturn target\nend\nfunction api.callback(field, value)\nif field.deprecated and type(field.deprecated.handler) == \"function\" then\nfield.deprecated.handler(value)\nif api._deprecations ~= \"off\" then\npremake.warnOnce(field.name, \"the field %s has been deprecated.\\n   %s\", field.name, field.deprecated.message or \"\")\nif api._deprecations == \"error\" then error(\"deprecation errors enabled\", 3) end\nend\nend\nlocal target = api.gettarget(field.scope)\nif not value then\nreturn target.configset[field.name]\nend\nlocal status, result = pcall(function ()\nif api.iskeyedfield(field) then\napi.setkeyvalue(target, field, value)\nelse\nlocal setter = api.getsetter(field, true)\nsetter(target, field.name, field, value)\nend\nend)\nif not status then\nif type(result) == \"table\" then\nresult = result.msg\nend\nerror(result, 3)\nend\nend\nfunction api.remove(field, value)\nif not value then return e"
	"nd\nlocal target = api.gettarget(field.scope)\nlocal kind = api.getbasekind(field)\nlocal removes = {}\nlocal remover = api[\"remove\" .. kind] or table.insert\nfunction check(value)\nif field.deprecated[value] then\nlocal handler = field.deprecated[value]\nif handler.remove then handler.remove(value) end\nif api._deprecations ~= \"off\" then\nlocal key = field.name .. \"_\" .. value\npremake.warnOnce(key, \"the %s value %s has been deprecated.\\n   %s\", field.name, value, handler.message or \"\")\nif api._deprecations == \"error\" then error(\"deprecation errors enabled\", 8) end\nend\nend\nend\nfunction recurse(value)\nif type(value) == \"table\" then\ntable.foreachi(value, function(v)\nrecurse(v)\nend)\nelse\nif field.deprecated then\nif value:contains(\"*\") then\nlocal current = target.configset[field.name]\nlocal mask = path.wildcards(value)\nfor _, item in ipairs(current) do\nif item:match(mask) == item then\ncheck(item)\nend\nend\nelse\nvalue, err = api.checkvalue(value, field)\nif err then error(err,"
	" 4) end\ncheck(value)\nend\nend\nremover(removes, value)\nend\nend\nrecurse(value)\nconfigset.removevalues(target.configset, field.name, removes)\nend\nfunction api.checkvalue(value, field)\nif field.aliases then\nfor k,v in pairs(field.aliases) do\nif value:lower() == k:lower() then\nvalue = v\nbreak\nend\nend\nend\nif field.allowed then\nif type(field.allowed) == \"function\" then\nreturn field.allowed(value)\nelse\nlocal n = #field.allowed\nfor i = 1, n do\nlocal v = field.allowed[i]\nif value:lower() == v:lower() then\nreturn v\nend\nend\nreturn nil, \"invalid value '\" .. value .. \"'\"\nend\nelse\nreturn value\nend\nend\nfunction api.comparevalues(field, value1, value2)\nif not value1 and not value2 then\nreturn true\nend\nif not value1 or not value2 then\nreturn false\nend\nif field.kind:startswith(\"key\") then\nfor k,v in pairs(value1) do\nif not value2[k] then\nreturn false\nend\nend\nfor k,v in pairs(value2) do\nif not value1[k] then\nreturn false\nend\nend\nreturn true\nelseif field.kind:endswith("
	"\"list\") then\nreturn #value1 == #value2\nelse\nreturn value1 == value2\nend\nend\nfunction api.getbasekind(field)\nlocal kind = field.kind\nif kind:startswith(\"key-\") then\nkind = kind:sub(5)\nend\nif kind:endswith(\"-list\") then\nkind = kind:sub(1, -6)\nend\nreturn kind\nend\nfunction api.iskeyedfield(field)\nreturn field.kind:startswith(\"key-\")\nend\nfunction api.islistfield(field)\nreturn field.kind:endswith(\"-list\")\nend\nfunction api.getsetter(field, lists)\nif lists and api.islistfield(field) then\nreturn api.setlist\nelse\nreturn api[\"set\" .. api.getbasekind(field)]\nend\nend\nfunction api.reset()\napi.scope = {\nroot = {\nconfigset = configset.root,\nblocks = {}  -- TODO: remove this when switch-over to new APIs is done\n}\n}\nend\napi.reset()\nfunction api.setarray(target, name, field, value)\ntarget = target.configset or target\nif type(value) ~= \"table\" then\nvalue = { value }\nend\ntarget[name] = value\nend\nfunction api.setfile(target, name, field, value)\nif value:find(\"*\") then\nl"
	"ocal values = os.matchfiles(value)\ntable.foreachi(values, function(v)\napi.setfile(target, name, field, v)\nname = name + 1\nend)\nelse\ntarget[name] = path.getabsolute(value)\nend\nend\nfunction api.setdirectory(target, name, field, value)\nif value:find(\"*\") then\nlocal values = os.matchdirs(value)\ntable.foreachi(values, function(v)\napi.setdirectory(target, name, field, v)\nname = name + 1\nend)\nelse\ntarget[name] = path.getabsolute(value)\nend\nend\nfunction api.removefile(target, value)\ntable.insert(target, path.getabsolute(value))\nend\napi.removedirectory = api.removefile\nfunction api.setkeyvalue(target, field, values)\nif type(values) ~= \"table\" then\nerror({ msg=\"value must be a table of key-value pairs\" })\nend\nlocal newval = {}\nlocal setter = api.getsetter(field, true)\nfor key, value in pairs(values) do\nsetter(newval, key, field, value)\nend\nconfigset.addvalue(target.configset, field.name, newval)\nend\nfunction api.setlist(target, name, field, value)\nlocal setter = api.getsetter(fi"
	"eld)\nif target.configset then\ntarget = target.configset\nend\nlocal result = {}\nfunction recurse(value)\nif type(value) == \"table\" then\ntable.foreachi(value, function (value)\nrecurse(value)\nend)\nelse\nsetter(result, #result + 1, field, value)\nend\nend\nrecurse(value)\ntarget[name] = result\nend\nfunction api.setmixed(target, name, field, value)\nif type(value) == \"string\" and value:find('/', nil, true) then\nvalue = path.getabsolute(value)\nend\nreturn api.setstring(target, name, field, value)\nend\nfunction api.setobject(target, name, field, value)\ntarget = target.configset or target\ntarget[name] = value\nend\nfunction api.setpath(target, name, field, value)\napi.setstring(target, name, field, path.getabsolute(value))\nend\nfunction api.setstring(target, name, field, value)\nif type(value) == \"table\" then\nerror({ msg=\"expected string; got table\" })\nend\nlocal value, err = api.checkvalue(value, field)\nif err then error({ msg=err }) end\nif field.deprecated and field.deprecated[value] then"
	"\nlocal handler = field.deprecated[value]\nhandler.add(value)\nif api._deprecations ~= \"off\" then\nlocal key = field.name .. \"_\" .. value\npremake.warnOnce(key, \"the %s value %s has been deprecated.\\n   %s\", field.name, value, handler.message or \"\")\nif api._deprecations == \"error\" then error({ msg=\"deprecation errors enabled\" }) end\nend\nend\ntarget = target.configset or target\ntarget[name] = value\nend\nfunction configuration(terms)\nif not terms then\nreturn api.scope.configuration\nend\nif terms == \"*\" then terms = nil end\nlocal container = api.scope.project or api.scope.solution or api.scope.root\nconfigset.addblock(container.configset, {terms}, os.getcwd())\nlocal cfg = {}\ncfg.configset = container.configset\napi.scope.configuration = cfg\nreturn cfg\nend\nfunction group(name)\nif name == \"*\" then name = nil end\napi.scope.group = name\nend\n  function project(name)\nif not name then\nif api.scope.project then\nname = api.scope.project.name\nelse\nreturn nil\nend\nend\nlocal sln = ap"
	"i.scope.solution\nif not sln then\nerror(\"no active solution\", 2)\nend\nlocal prj\nif name ~= \"*\" then\nprj = sln.projects[name]\nif not prj then\nprj = premake.project.new(sln, name)\nprj.group = api.scope.group or \"\"\npremake.solution.addproject(sln, prj)\nend\nend\napi.scope.project = prj\nconfiguration {}\nreturn prj\nend\nfunction external(name)\nlocal prj = project(name)\nprj.external = true;\nreturn prj\nend\nfunction solution(name)\nif not name then\nif api.scope.solution then\nname = api.scope.solution.name\nelse\nreturn nil\nend\nend\nif name == \"*\" then\napi.scope.solution = nil\nelse\nend\nlocal sln\nif name ~= \"*\" then\nsln = premake.solution.get(name) or premake.solution.new(name)\nend\napi.scope.solution = sln\napi.scope.project = nil\napi.scope.group = nil\nconfiguration {}\nreturn sln\nend\nfunction newaction(a)\npremake.action.add(a)\nend\nfunction newoption(opt)\npremake.option.add(opt)\nend\n",

	/* base/detoken.lua */
	"premake.detoken = {}\nlocal detoken = premake.detoken\nfunction detoken.expand(value, environ, ispath, basedir)\nsetmetatable(environ, {__index = _G})\nfunction expandtoken(token, environ)\nlocal func, err = loadstring(\"return \" .. token)\nif not func then\nreturn nil, err\nend\nsetfenv(func, environ)\nlocal result = func() or \"\"\nlocal isAbs = path.isabsolute(result)\nif isAbs and ispath then\nresult = \"\\0\" .. result\nend\nif isAbs and not ispath and basedir then\nresult = path.getrelative(basedir, result)\nend\nreturn result\nend\nfunction expandvalue(value)\nlocal count\nrepeat\nvalue, count = value:gsub(\"%%{(.-)}\", function(token)\nlocal result, err = expandtoken(token, environ)\nif not result then\nerror(err, 0)\nend\nreturn result\nend)\nuntil count == 0\nif ispath then\nlocal i, j\nrepeat\ni, j = value:find(\"\\0\")\nif i then\nvalue = value:sub(i + 1)\nend\nuntil not i\nend\nreturn value\nend\nfunction recurse(value)\nif type(value) == \"table\" then\nfor k, v in pairs(value) do\nvalue[k] = re"
	"curse(v)\nend\nreturn value\nelse\nreturn expandvalue(value)\nend\nend\nreturn recurse(value)\nend\n",

	/* base/using.lua */
	"premake.packages = {}\nfunction using(pkg)\nlocal pattern\nif(not _OPTIONS[\"os\"]) then _OPTIONS[\"os\"] = os.get() end\nif(not _OPTIONS[\"platform\"]) then\n_OPTIONS[\"platform\"] = \"x64\"\nend\nif    (_OPTIONS[\"os\"] == \"windows\") then pattern = \";\"\nelseif(_OPTIONS[\"os\"] ==   \"linux\") then pattern = \":\"\nend\nif(_OPTIONS[\"includedirs\"]) then\nlocal arr = string.explode(_OPTIONS[\"includedirs\"], pattern)\nfor _, t in ipairs(arr) do\nif(os.isdir(t)) then includedirs { t }\nelse error(\"Error: os.isdir(\"..t..\") return false\")\nend\nend\nend\nif(_OPTIONS[\"libdirs\"]) then\nlocal arr = string.explode(_OPTIONS[\"libdirs\"], pattern)\nfor _, t in ipairs(arr) do\nif(os.isdir(t)) then libdirs { t }\nelse error(\"Error: os.isdir(\"..t..\") return false\")\nend\nend\nend\nif(not pkg or not pkg.name) then\nprint(\"Error: use \\\"using\\\" without package.name\")\nreturn nil\nend\nif(not premake.packages[pkg.name]) then\nprint(\"Warning: package \"..pkg.name..\" not supported\")\nreturn nil\nend\nif("
	"_OPTIONS[\"os\"] == \"linux\") then\nincludedirs { \"/usr/include/\", \"/usr/local/include/\" }\nlibdirs { \"/usr/lib/\", \"/usr/lib/x86_64-linux-gnu/\" }\nend\nreturn premake.packages[pkg.name].config(pkg)\nend\nfunction findin(dirs, name)\nfor _, t in ipairs(dirs) do\nif(os.isdir(path.join(t, name)) or os.isfile(path.join(t, name))) then return t end\nend\nreturn nil\nend\n",

	/* base/project.lua */
	"premake.project = {}\nlocal project = premake.project\nlocal configset = premake.configset\nlocal context = premake.context\nlocal tree = premake.tree\nfunction project.new(sln, name)\nlocal prj = {}\nprj.name = name\nprj.solution = sln\nprj.script = _SCRIPT\nprj.blocks = {}\nlocal cset = configset.new(sln.configset)\ncset.basedir = os.getcwd()\ncset.filename = name\ncset.uuid = os.uuid(name)\nprj.configset = cset\nsetmetatable(prj, {\n__type = \"project\",\n__index = function(prj, key)\nreturn prj.configset[key]\nend,\n})\nreturn prj\nend\nfunction project.bake(prj, sln)\nlocal environ = {}\nlocal ctx = context.new(prj.configset, environ)\ncontext.addterms(ctx, _ACTION)\nctx.system = ctx.system or premake.action.current().os or os.get()\ncontext.addterms(ctx, ctx.system)\ncontext.addterms(ctx, ctx.architecture)\ncontext.addterms(ctx, ctx.kind)\ncontext.compile(ctx)\nctx.baked = true\nfor key, value in pairs(prj) do\nctx[key] = value\nend\nctx.solution = sln\nctx.project = ctx\nenviron.sln = sln\nenviron.prj ="
	" ctx\nctx.location = ctx.location or sln.location or prj.basedir\ncontext.basedir(ctx, ctx.location)\nlocal cfgs = table.fold(ctx.configurations or {}, ctx.platforms or {})\nproject.bakeconfigmap(ctx, prj.configset, cfgs)\nctx._cfglist = project.bakeconfiglist(ctx, cfgs)\nctx.system = nil\nctx.configs = {}\nfor _, pairing in ipairs(ctx._cfglist) do\nlocal buildcfg = pairing[1]\nlocal platform = pairing[2]\nlocal cfg = project.bakeconfig(ctx, buildcfg, platform)\nif premake.action.supportsconfig(cfg) then\nctx.configs[(buildcfg or \"*\") .. (platform or \"\")] = cfg\nend\nend\nctx._ = {}\nctx._.files = project.bakeFiles(ctx)\nif project.iscpp(ctx) then\nproject.assignObjectSequences(ctx)\nend\nreturn ctx\nend\nfunction project.bakeFiles(prj)\nlocal files = {}\nfor cfg in project.eachconfig(prj) do\ntable.foreachi(cfg.files, function(fname)\nif not files[fname] then\nlocal fcfg = premake.fileconfig.new(fname, prj)\nfiles[fname] = fcfg\ntable.insert(files, fcfg)\nend\npremake.fileconfig.addconfig(files[fname], cf"
	"g)\nend)\nend\ntable.sort(files, function(a,b)\nreturn a.vpath < b.vpath\nend)\nreturn files\nend\nfunction project.assignObjectSequences(prj)\nlocal bases = {}\ntable.foreachi(prj._.files, function(file)\nif not path.iscppfile(file.abspath) then\nreturn\nend\nif not bases[file.basename] then\nbases[file.basename] = {}\nend\nlocal sequences = bases[file.basename]\nfor cfg in project.eachconfig(prj) do\nlocal fcfg = premake.fileconfig.getconfig(file, cfg)\nif fcfg ~= nil and not fcfg.flags.ExcludeFromBuild then\nfcfg.sequence = sequences[cfg] or 0\nsequences[cfg] = fcfg.sequence + 1\nend\nend\nfile.sequence = sequences[prj] or 0\nsequences[prj] = file.sequence + 1\nend)\nend\nfunction project.bakeconfigmap(ctx, cset, cfgs)\nlocal terms = table.arraycopy(ctx.terms)\nfor _, cfg in ipairs(cfgs) do\nif cfg[1] then table.insert(terms, cfg[1]:lower()) end\nif cfg[2] then table.insert(terms, cfg[2]:lower()) end\nend\nlocal map = configset.fetchvalue(cset, \"configmap\", terms)\nif map then\nfor key, value in pairs(map"
	") do\nctx.configmap[key] = value\nend\nend\nend\nfunction project.bakeconfiglist(ctx, cfgs)\nfor i, cfg in ipairs(cfgs) do\ncfgs[i] = project.mapconfig(ctx, cfg[1], cfg[2])\nend\nlocal buildcfgs = {}\nlocal platforms = {}\nfor _, pairing in ipairs(cfgs) do\nlocal buildcfg = pairing[1]\nlocal platform = pairing[2]\nif not table.contains(buildcfgs, buildcfg) then\ntable.insert(buildcfgs, buildcfg)\nend\nif platform and not table.contains(platforms, platform) then\ntable.insert(platforms, platform)\nend\nend\nreturn table.fold(buildcfgs, platforms)\nend\nfunction project.bakeconfig(prj, buildcfg, platform)\nlocal system = premake.action.current().os or os.get()\nlocal architecture = nil\nif platform then\nsystem = premake.api.checkvalue(platform, premake.fields.system) or system\narchitecture = premake.api.checkvalue(platform, premake.fields.architecture) or architecture\nend\nlocal environ = {\nsln = prj.solution,\nprj = prj,\n}\nlocal ctx = context.new(prj.configset, environ)\nctx.project = prj\nctx.solution = "
	"prj.solution\nctx.buildcfg = buildcfg\nctx.platform = platform\nctx.action = _ACTION\nenviron.cfg = ctx\ncontext.addterms(ctx, buildcfg)\ncontext.addterms(ctx, platform)\ncontext.addterms(ctx, _ACTION)\ncontext.addterms(ctx, prj.language)\nctx.system = ctx.system or system\ncontext.addterms(ctx, ctx.system)\nctx.architecture = ctx.architecture or architecture\ncontext.addterms(ctx, ctx.architecture)\ncontext.addterms(ctx, ctx.kind)\ncontext.compile(ctx)\nctx.location = ctx.location or prj.location\ncontext.basedir(ctx, ctx.location)\npremake.config.bake(ctx)\nreturn ctx\nend\nfunction project.eachconfig(prj)\nif not prj.baked then\nprj = project.bake(prj, prj.solution)\nend\nlocal configs = prj._cfglist\nlocal count = #configs\nlocal i = 0\nreturn function ()\ni = i + 1\nif i <= count then\nreturn project.getconfig(prj, configs[i][1], configs[i][2])\nend\nend\nend\nfunction project.findClosestMatch(prj, buildcfg, platform)\nbuildcfg = project.mapconfig(prj, buildcfg)[1]\nplatform = project.mapconfig(prj, platf"
	"orm)[1]\nif not table.contains(prj.configurations, buildcfg) then\nbuildcfg = prj.configurations[1]\nend\nif not table.contains(prj.platforms, platform) then\nplatform = prj.platforms[1]\nend\nreturn project.getconfig(prj, buildcfg, platform)\nend\nfunction project.findproject(name)\nfor sln in premake.solution.each() do\nfor _, prj in ipairs(sln.projects) do\nif (prj.name == name) then\nreturn  prj\nend\nend\nend\nend\nfunction project.getconfig(prj, buildcfg, platform)\nif not prj.baked then\nprj = project.bake(prj, prj.solution)\nend\nif not buildcfg then\nreturn prj\nend\nlocal pairing = project.mapconfig(prj, buildcfg, platform)\nbuildcfg = pairing[1]\nplatform = pairing[2]\nlocal key = (buildcfg or \"*\") .. (platform or \"\")\nreturn prj.configs[key]\nend\nfunction project.getdependencies(prj)\nif not prj.dependencies then\nlocal result = {}\nlocal function add_to_project_list(cfg, depproj, result)\nlocal dep = premake.solution.findproject(cfg.solution, depproj)\nif dep and not table.contains(result, de"
	"p) then\ntable.insert(result, dep)\nend\nend\nfor cfg in project.eachconfig(prj) do\nfor _, link in ipairs(cfg.links) do\nadd_to_project_list(cfg, link, result)\nend\nfor _, depproj in ipairs(cfg.dependson) do\nadd_to_project_list(cfg, depproj, result)\nend\nend\nprj.dependencies = result\nend\nreturn prj.dependencies\nend\nfunction project.getfilename(prj, ext)\nlocal fn = prj.location\nif ext and not ext:startswith(\".\") then\nfn = path.join(fn, ext)\nelse\nfn = path.join(fn, prj.filename)\nif ext then\nfn = fn .. ext\nend\nend\nreturn fn\nend\nfunction project.getfirstconfig(prj)\nlocal iter = project.eachconfig(prj)\nlocal first = iter()\nreturn first\nend\nfunction project.getrelative(prj, filename)\nif type(filename) == \"table\" then\nlocal result = {}\nfor i, name in ipairs(filename) do\nresult[i] = project.getrelative(prj, name)\nend\nreturn result\nelse\nif filename then\nreturn path.getrelative(prj.location, filename)\nend\nend\nend\nfunction project.getsourcetree(prj, sorter)\nif prj._.sourcetree "
	"then\nreturn prj._.sourcetree\nend\nlocal tr = tree.new(prj.name)\ntable.foreachi(prj._.files, function(fcfg)\nlocal flags\nif fcfg.vpath ~= fcfg.relpath then\nflags = { trim = false }\nend\nlocal parent = tree.add(tr, path.getdirectory(fcfg.vpath), flags)\nlocal node = tree.insert(parent, tree.new(path.getname(fcfg.vpath)))\nsetmetatable(node, { __index = fcfg })\nend)\ntree.trimroot(tr)\ntree.sort(tr, sorter)\nprj._.sourcetree = tr\nreturn tr\nend\nfunction project.getvpath(prj, filename)\nlocal vpath = filename\nfor replacement,patterns in pairs(prj.vpaths or {}) do\nfor _,pattern in ipairs(patterns) do\nlocal i = filename:find(path.wildcards(pattern))\nif i == 1 then\nlocal leaf\ni = pattern:find(\"*\", 1, true) or (pattern:len() + 1)\nif i < filename:len() then\nleaf = filename:sub(i)\nelse\nleaf = path.getname(filename)\nend\nif leaf:startswith(\"/\") then\nleaf = leaf:sub(2)\nend\nlocal stem = \"\"\nif replacement:len() > 0 then\nstem, stars = replacement:gsub(\"%*\", \"\")\nif stars == 0 then\nleaf = p"
	"ath.getname(leaf)\nend\nelse\nleaf = path.getname(leaf)\nend\nvpath = path.join(stem, leaf)\nend\nend\nend\nreturn vpath\nend\nfunction project.hasConfig(prj, func)\nfor cfg in project.eachconfig(prj) do\nif func(cfg) then\nreturn true\nend\nend\nend\nfunction project.hasfile(prj, filename)\nreturn (prj._.files[filename] ~= nil)\nend\nfunction project.isc(prj)\nreturn prj.language == premake.C\nend\nfunction project.iscpp(prj)\nreturn prj.language == premake.C or prj.language == premake.CPP\nend\nfunction project.isdotnet(prj)\nreturn prj.language == premake.CSHARP\nend\nfunction project.mapconfig(prj, buildcfg, platform)\nlocal pairing = { buildcfg, platform }\nlocal testpattern = function(pattern, pairing, i)\nlocal j = 1\nwhile i <= #pairing and j <= #pattern do\nif pairing[i] ~= pattern[j] then\nreturn false\nend\ni = i + 1\nj = j + 1\nend\nreturn true\nend\nfor pattern, replacements in pairs(prj.configmap or {}) do\nif type(pattern) ~= \"table\" then\npattern = { pattern }\nend\nfor i = 1, #pairing do\nif"
	" testpattern(pattern, pairing, i) then\nif #pattern == 1 and #replacements == 1 then\npairing[i] = replacements[1]\nelse\npairing = { replacements[1], replacements[2] }\nend\nend\nend\nend\nreturn pairing\nend\n",

	/* base/config.lua */
	"premake.config = {}\nlocal project = premake.project\nlocal config = premake.config\nlocal context = premake.context\nfunction config.bake(cfg)\ncfg.longname = table.concat({ cfg.buildcfg, cfg.platform }, \"|\")\ncfg.shortname = table.concat({ cfg.buildcfg, cfg.platform }, \" \")\ncfg.shortname = cfg.shortname:gsub(\" \", \"_\"):lower()\ncfg.name = cfg.longname\nif cfg.project and cfg.kind then\ncfg.buildtarget = config.gettargetinfo(cfg)\ncfg.buildtarget.relpath = project.getrelative(cfg.project, cfg.buildtarget.abspath)\ncfg.linktarget = config.getlinkinfo(cfg)\ncfg.linktarget.relpath = project.getrelative(cfg.project, cfg.linktarget.abspath)\nend\nend\nlocal function buildtargetinfo(cfg, kind, field)\nlocal basedir = cfg.project.location\nlocal directory = cfg[field..\"dir\"] or cfg.targetdir or basedir\nlocal basename = cfg[field..\"name\"] or cfg.targetname or cfg.project.name\nlocal prefix = cfg[field..\"prefix\"] or cfg.targetprefix or \"\"\nlocal suffix = cfg[field..\"suffix\"] or cfg.targetsuffix or "
	"\"\"\nlocal extension = cfg[field..\"extension\"] or \"\"\nlocal bundlename = \"\"\nlocal bundlepath = \"\"\nif cfg.system == premake.MACOSX and kind == premake.WINDOWEDAPP then\nbundlename = basename .. \".app\"\nbundlepath = path.join(bundlename, \"Contents/MacOS\")\nend\nlocal info = {}\ninfo.directory  = directory\ninfo.basename   = basename .. suffix\ninfo.name       = prefix .. info.basename .. extension\ninfo.extension  = extension\ninfo.abspath    = path.join(directory, info.name)\ninfo.fullpath   = info.abspath\ninfo.bundlename = bundlename\ninfo.bundlepath = path.join(directory, bundlepath)\ninfo.prefix     = prefix\ninfo.suffix     = suffix\nreturn info\nend\nfunction config.canlink(cfg, target, linkage)\nif type(target) ~= \"string\" then\nif target.kind ~= \"SharedLib\" and target.kind ~= \"StaticLib\" then\nreturn false\nend\nlocal cfgManaged = project.isdotnet(cfg.project) or (cfg.flags.Managed ~= nil)\nlocal tgtManaged = project.isdotnet(target.project) or (target.flags.Managed ~= nil)\nreturn "
	"(cfgManaged == tgtManaged)\nend\nif project.isdotnet(cfg.project) then\nreturn true\nend\nlocal isManaged = (path.getextension(target) == \".dll\")\nif isManaged and not cfg.flags.Managed then\nreturn false\nend\nreturn (isManaged) == (linkage == \"managed\")\nend\nfunction config.canLinkIncremental(cfg)\nif cfg.kind == \"StaticLib\"\nor config.isOptimizedBuild(cfg)\nor cfg.flags.NoIncrementalLink then\nreturn false\nend\nreturn true\nend\nfunction config.decoratelink(cfg, target, linkage)\nlocal ext\nif cfg.system == premake.WINDOWS then\nif project.isdotnet(cfg.project) or linkage == \"managed\" then\next = \".dll\"\nelseif project.iscpp(cfg.project) then\next = \".lib\"\nend\nelseif cfg.system == premake.XBOX360 then\nif project.iscpp(cfg.project) then\next = \".lib\"\nend\nend\ntarget = path.appendextension(target, ext)\nif target:find(\"/\", nil, true) then\ntarget = project.getrelative(cfg.project, target)\nend\nreturn target\nend\nfunction config.findfile(cfg, ext)\nfor _, fname in ipairs(cfg.files) do"
	"\nif fname:endswith(ext) then\nreturn project.getrelative(cfg.project, fname)\nend\nend\nend\nfunction config.getlinkinfo(cfg)\nlocal kind = cfg.kind\nlocal field = \"target\"\nif project.iscpp(cfg.project) then\nif cfg.system == premake.WINDOWS and kind == premake.SHAREDLIB and not cfg.flags.NoImportLib then\nkind = premake.STATICLIB\nfield = \"implib\"\nend\nend\nreturn buildtargetinfo(cfg, kind, field)\nend\nfunction config.getlookupkey(cfg)\nreturn (cfg.buildcfg or \"*\") .. (cfg.platform or \"\")\nend\n function config.getlinks(cfg, kind, part, linkage)\nlocal result = {}\nif part == \"directory\" then\ntable.foreachi(cfg.libdirs, function(dir)\ntable.insert(result, project.getrelative(cfg.project, dir))\nend)\nend\ntable.foreachi(cfg.links, function(link)\nlocal item\nlocal prj = premake.solution.findproject(cfg.solution, link)\nif prj and kind ~= \"system\" then\nlocal prjcfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)\nif prjcfg and (kind == \"dependencies\" or config.canlink(cfg, prjcfg)) the"
	"n\nif part == \"object\" then\nitem = prjcfg\nelseif not prj.external then\nitem = project.getrelative(cfg.project, prjcfg.linktarget.fullpath)\nend\nend\nelseif not prj and (kind == \"system\" or kind == \"all\") then\nif config.canlink(cfg, link, linkage) then\nitem = config.decoratelink(cfg, link, linkage)\nend\nend\nif item then\nif part == \"directory\" then\nitem = path.getdirectory(item)\nif item == \".\" then\nitem = nil\nend\nelseif part == \"name\" then\nitem = path.getname(item)\nelseif part == \"basename\" then\nitem = path.getbasename(item)\nelseif type(part) == \"function\" then\npart(link, item)\nend\nend\nif item and not table.contains(result, item) then\ntable.insert(result, item)\nend\nend)\nreturn result\nend\nfunction config.getruntime(cfg)\nlocal linkage = iif(cfg.flags.StaticRuntime, \"Static\", \"Shared\")\nlocal mode = iif(config.isDebugBuild(cfg) and not cfg.flags.ReleaseRuntime, \"Debug\", \"Release\")\nreturn linkage .. mode\nend\nfunction config.gettargetinfo(cfg)\nreturn buildtarge"
	"tinfo(cfg, cfg.kind, \"target\")\nend\nfunction config.isCopyLocal(cfg, linkname, default)\nif cfg.flags.NoCopyLocal then\nreturn false\nend\nif #cfg.copylocal > 0 then\nreturn table.contains(cfg.copylocal, linkname)\nend\nreturn default\nend\nfunction config.isDebugBuild(cfg)\nreturn cfg.flags.Symbols and not config.isOptimizedBuild(cfg)\nend\nfunction config.isOptimizedBuild(cfg)\nreturn cfg.optimize ~= nil and cfg.optimize ~= \"Off\" and cfg.optimize ~= \"Debug\"\nend\nfunction config.linksToProject(cfg, prjName)\nprjName = prjName:lower()\nlocal n = #cfg.links\nfor i = 1,n do\nif cfg.links[i]:lower() == prjName then\nreturn true\nend\nend\nend\nfunction config.mapFlags(cfg, mappings)\nlocal flags = {}\nfor field, map in pairs(mappings) do\nlocal values = cfg[field]\ntable.foreachi(values, function(value)\nlocal flag = map[value]\nif type(flag) == \"function\" then\nflag = flag(cfg)\nend\nif flag then\ntable.insertflat(flags, flag)\nend\nend)\nend\nreturn flags\nend\n",

	/* base/fileconfig.lua */
	"premake.fileconfig = {}\nlocal fileconfig = premake.fileconfig\nlocal context = premake.context\nlocal project = premake.project\nfileconfig.fcfg_mt = {}\nfileconfig.fsub_mt = {}\nfunction fileconfig.new(fname, prj)\nlocal fcfg = {}\nfcfg.project = prj\nfcfg.configs = {}\nfcfg.abspath = fname\nsetmetatable(fcfg, fileconfig.fcfg_mt)\nlocal vpath = project.getvpath(prj, fname)\nif vpath ~= fcfg.abspath then\nfcfg.vpath = vpath\nend\nreturn fcfg\nend\nfunction fileconfig.addconfig(fcfg, cfg)\nlocal environ = {}\nlocal fsub = context.new(cfg.project.configset, environ, fcfg.abspath)\ncontext.copyterms(fsub, cfg)\nfcfg.configs[cfg] = fsub\nfor key, value in pairs(cfg.environ) do\nenviron[key] = value\nend\nenviron.file = fsub\ncontext.compile(fsub)\nfsub.abspath = fcfg.abspath\nfsub.vpath = fcfg.vpath\nfsub.config = cfg\nfsub.project = cfg.project\ncontext.basedir(fsub, cfg.project.location)\nsetmetatable(fsub, fileconfig.fsub_mt)\nend\nfunction fileconfig.getconfig(fcfg, cfg)\nreturn fcfg.configs[cfg]\nend\nfuncti"
	"on fileconfig.hasCustomBuildRule(fcfg)\nreturn fcfg and (#fcfg.buildcommands > 0) and (#fcfg.buildoutputs > 0)\nend\nfunction fileconfig.hasFileSettings(fcfg)\nfor key, field in pairs(premake.fields) do\nif field.scope == \"config\" then\nlocal value = fcfg[field.name]\nif value then\nif type(value) == \"table\" then\nif #value > 0 then\nreturn true\nend\nelse\nreturn true\nend\nend\nend\nend\nreturn false\nend\nlocal fcfg_mt = fileconfig.fcfg_mt\nfcfg_mt.__index = function(file, key)\nif type(fcfg_mt[key]) == \"function\" then\nreturn fcfg_mt[key](file)\nend\nend\nfileconfig.fsub_mt.__index = function(fcfg, key)\nreturn fcfg_mt.__index(fcfg, key) or context.__mt.__index(fcfg, key)\nend\nfunction fcfg_mt.basename(fcfg)\nreturn path.getbasename(fcfg.abspath)\nend\nfunction fcfg_mt.name(fcfg)\nreturn path.getname(fcfg.abspath)\nend\nfunction fcfg_mt.objname(fcfg)\nif fcfg.sequence ~= nil and fcfg.sequence > 0 then\nreturn fcfg.basename .. fcfg.sequence\nelse\nreturn fcfg.basename\nend\nend\nfunction fcfg_mt.path"
	"(fcfg)\nreturn fcfg.relpath\nend\nfunction fcfg_mt.relpath(fcfg)\nreturn project.getrelative(fcfg.project, fcfg.abspath)\nend\nfunction fcfg_mt.vpath(fcfg)\nreturn fcfg.relpath\nend\n",

	/* base/solution.lua */
	"premake.solution = { }\nlocal solution = premake.solution\nlocal project = premake.project\nlocal configset = premake.configset\nlocal context = premake.context\nlocal tree = premake.tree\npremake.solution.list = { }\nfunction solution.new(name)\nlocal sln = {}\ntable.insert(premake.solution.list, sln)\npremake.solution.list[name] = sln\nsln.name = name\nsln.blocks = {}\nsln.projects = {}\nlocal cset = configset.new(configset.root)\ncset.basedir = os.getcwd()\ncset.filename = name\nsln.configset = cset\nsetmetatable(sln, {\n__type = \"solution\",\n__index = function(sln, key)\nreturn sln.configset[key]\nend,\n})\nreturn sln\nend\nfunction solution.addproject(sln, prj)\ntable.insert(sln.projects, prj)\nsln.projects[prj.name] = prj\nend\nfunction solution.bakeall()\nlocal result = {}\nfor i, sln in ipairs(solution.list) do\nresult[i] = solution.bake(sln)\nend\nsolution.list = result\nend\nfunction solution.bake(sln)\nlocal environ = {\nsln = sln,\n}\nlocal ctx = context.new(sln.configset, environ)\nctx.name = sl"
	"n.name\nctx.baked = true\ncontext.addterms(ctx, _ACTION)\ncontext.compile(ctx)\nctx.location = ctx.location or sln.basedir\ncontext.basedir(ctx, ctx.location)\nlocal projects = {}\nfor i, prj in ipairs(sln.projects) do\nprojects[i] = project.bake(prj, ctx)\nprojects[prj.name] = projects[i]\nend\nctx.projects = projects\nctx.location = ctx.location or sln.basedir\nsolution.bakeobjdirs(ctx)\nctx.configs = solution.bakeconfigs(ctx)\nreturn ctx\nend\nfunction solution.bakeconfigs(sln)\nlocal buildcfgs = sln.configurations or {}\nlocal platforms = sln.platforms or {}\nlocal configs = {}\nfor _, buildcfg in ipairs(buildcfgs) do\nif #platforms > 0 then\nfor _, platform in ipairs(platforms) do\ntable.insert(configs, { [\"buildcfg\"] = buildcfg, [\"platform\"] = platform })\nend\nelse\ntable.insert(configs, { [\"buildcfg\"] = buildcfg })\nend\nend\nfor _, cfg in ipairs(configs) do\ncfg.solution = sln\npremake.config.bake(cfg)\nend\nreturn configs\nend\nfunction solution.bakeobjdirs(sln)\nlocal function getobjdirs(cfg)"
	"\nlocal dirs = {}\nlocal dir = path.getabsolute(path.join(cfg.project.location, cfg.objdir or \"obj\"))\ntable.insert(dirs, dir)\nif cfg.platform then\ndir = path.join(dir, cfg.platform)\ntable.insert(dirs, dir)\nend\ndir = path.join(dir, cfg.buildcfg)\ntable.insert(dirs, dir)\ndir = path.join(dir, cfg.project.name)\ntable.insert(dirs, dir)\nreturn dirs\nend\nlocal counts = {}\nlocal configs = {}\nfor prj in premake.solution.eachproject(sln) do\nfor cfg in project.eachconfig(prj) do\nlocal dirs = getobjdirs(cfg)\nconfigs[cfg] = dirs\nfor _, dir in ipairs(dirs) do\ncounts[dir] = (counts[dir] or 0) + 1\nend\nend\nend\nfor cfg, dirs in pairs(configs) do\nfor _, dir in ipairs(dirs) do\nif counts[dir] == 1 then\ncfg.objdir = dir\nbreak\nend\nend\nend\nend\nfunction solution.each()\nlocal i = 0\nreturn function ()\ni = i + 1\nif i <= #premake.solution.list then\nreturn premake.solution.list[i]\nend\nend\nend\nfunction solution.eachconfig(sln)\nif not sln.baked then\nsln = solution.bake(sln)\nend\nlocal i = 0\nreturn"
	" function()\ni = i + 1\nif i > #sln.configs then\nreturn nil\nelse\nreturn sln.configs[i]\nend\nend\nend\nfunction solution.eachproject(sln)\nlocal i = 0\nreturn function ()\ni = i + 1\nif i <= #sln.projects then\nreturn premake.solution.getproject(sln, i)\nend\nend\nend\nfunction solution.findproject(sln, name)\nname = name:lower()\nfor _, prj in ipairs(sln.projects) do\nif name == prj.name:lower() then\nreturn prj\nend\nend\nreturn nil\nend\nfunction solution.get(key)\nreturn premake.solution.list[key]\nend\nsolution.getfilename = project.getfilename\nfunction solution.grouptree(sln)\nif sln.grouptree then\nreturn sln.grouptree\nend\nlocal tr = tree.new()\nfor prj in solution.eachproject(sln) do\nlocal prjpath = path.join(prj.group, prj.name)\nlocal node = tree.add(tr, prjpath)\nnode.project = prj\nend\ntree.traverse(tr, {\nonnode = function(node)\nnode.uuid = os.uuid(node.path)\nend\n})\nsln.grouptree = tr\nreturn tr\nend\nfunction solution.getproject(sln, idx)\nif not sln.baked then\nsln = solution.bake(sl"
	"n)\nend\nreturn sln.projects[idx]\nend\nfunction solution.hascppproject(sln)\nfor prj in solution.eachproject(sln) do\nif project.iscpp(prj) then\nreturn true\nend\nend\nreturn false\nend\nfunction solution.hasdotnetproject(sln)\nfor prj in solution.eachproject(sln) do\nif project.isdotnet(prj) then\nreturn true\nend\nend\nreturn false\nend\n",

	/* base/premake.lua */
	"local solution = premake.solution\nlocal project = premake.project\nlocal config = premake.config\npremake.extensions = {}\nlocal warnings = {}\npremake.C           = \"C\"\npremake.C7          = \"c7\"\npremake.CLANG       = \"clang\"\npremake.CONSOLEAPP  = \"ConsoleApp\"\npremake.CPP         = \"C++\"\npremake.CSHARP      = \"C#\"\npremake.GCC         = \"gcc\"\npremake.HAIKU       = \"haiku\"\npremake.LINUX       = \"linux\"\npremake.MACOSX      = \"macosx\"\npremake.MAKEFILE    = \"Makefile\"\npremake.NONE        = \"None\"\npremake.OFF         = \"Off\"\npremake.POSIX       = \"posix\"\npremake.PS3         = \"ps3\"\npremake.SHAREDLIB   = \"SharedLib\"\npremake.STATICLIB   = \"StaticLib\"\npremake.UNIVERSAL   = \"universal\"\npremake.WINDOWEDAPP = \"WindowedApp\"\npremake.WINDOWS     = \"windows\"\npremake.X32         = \"x32\"\npremake.X64         = \"x64\"\npremake.XBOX360     = \"xbox360\"\nfunction premake.callarray(namespace, array, ...)\nlocal n = #array\nfor i = 1, n do\nlocal fn = namespace[array["
	"i]]\nif not fn then\n                error(string.format(\"Unable to find function '%s'\", array[i]))\nend\nfn(...)\nend\nend\nfunction premake.clearWarnings()\nwarnings = {}\nend\nfunction premake.error(message, ...)\nerror(string.format(\"** Error: \" .. message, ...), 0)\nend\nfunction premake.esc(value)\nif not io.esc then\nreturn value\nend\nif type(value) == \"table\" then\nlocal result = {}\ntable.foreachi(value, function(v)\ntable.insert(result, premake.esc(v))\nend)\nreturn result\nelse\nif io.esc then\nvalue = io.esc(value)\nend\nreturn value\nend\nend\nfunction premake.generate(obj, ext, callback)\nlocal fn = premake.project.getfilename(obj, ext)\nprintf(\"Generating %s...\", path.getrelative(os.getcwd(), fn))\nlocal f, err = io.open(fn, \"wb\")\nif (not f) then\nerror(err, 0)\nend\nio.output(f)\ncallback(obj)\nf:close()\nend\nfunction premake.override(scope, name, repl)\nlocal original = scope[name]\nscope[name] = function(...)\nreturn repl(original, ...)\nend\nend\nfunction premake.quoted(value)\n"
	"local q = value:find(\" \", 1, true)\nif not q then\nq = value:find(\"$%(.-%)\", 1)\nend\nif q then\nvalue = '\"' .. value .. '\"'\nend\nreturn value\nend\nfunction premake.validate()\nlocal ctx = {}\nfor sln in solution.each() do\npremake.validateSolution(sln, ctx)\nfor prj in solution.eachproject(sln) do\npremake.validateProject(prj, ctx)\nfor cfg in project.eachconfig(prj) do\npremake.validateConfig(cfg, ctx)\nend\nend\nend\nend\nfunction premake.validateSolution(sln, ctx)\nif not sln.configurations or #sln.configurations == 0 then\npremake.error(\"solution '%s' does not contain any configurations\", sln.name)\nend\nlocal uuids = {}\nfor prj in solution.eachproject(sln) do\nif uuids[prj.uuid] then\npremake.error(\"projects '%s' and '%s' have the same UUID\", uuids[prj.uuid], prj.name)\nend\nuuids[prj.uuid] = prj.name\nend\nend\nfunction premake.validateProject(prj, ctx)\nif not prj.language then\npremake.error(\"project '%s' does not have a language\", prj.name)\nend\npremake.validateScopes(prj, \"project\""
	", ctx)\nend\nfunction premake.validateConfig(cfg, ctx)\nif not cfg.kind then\npremake.error(\"project '%s' needs a kind in configuration '%s'\", cfg.project.name, cfg.name)\nend\nif (cfg.kind == premake.MAKEFILE or cfg.kind == premake.NONE) and not project.iscpp(cfg.project) then\npremake.error(\"project '%s' uses %s kind in configuration '%s'; language must be C++\", cfg.project.name, cfg.kind, cfg.name)\nend\npremake.validateScopes(cfg, \"config\", ctx)\nend\nfunction premake.validateScopes(cfg, expected, ctx)\nfor name, field in pairs(premake.fields) do\nlocal okay = false\nif field.scope == \"config\" or field.scope == expected then\nokay = true\nend\nif not okay then\nokay = premake.api.comparevalues(field, cfg[field.scope][name], cfg[name])\nend\nif not okay then\nlocal key = \"validate.\" .. field.name\npremake.warnOnce(key, \"'%s' on %s '%s' differs from %s '%s'; may be set out of scope\", name, expected, cfg.name, field.scope, cfg[field.scope].name)\nend\nend\nend\nfunction premake.warn(message, ...)"
	"\nio.stderr:write(string.format(\"** Warning: \" .. message .. \"\\n\", ...))\nend\nfunction premake.warnOnce(key, message, ...)\nif not warnings[key] then\nwarnings[key] = true\npremake.warn(message, ...)\nend\nend\n",

	/* _premake_init.lua */
	"local api = premake.api\nlocal DOC_URL = \"See https://bitbucket.org/premake/premake-dev/wiki/\"\nlocal home = os.getenv(\"HOME\") or os.getenv(\"USERPROFILE\")\nlocal packagePaths = {\npath.join(home, \".premake/?/?.lua\"),\n\"./modules/?/?.lua\",\npath.join(path.getdirectory(_PREMAKE_COMMAND), \"modules/?/?.lua\"),\npath.join(home, \"Library/Application Support/Premake/?/?.lua\"),\n\"/usr/local/share/premake/?/?.lua\",\n\"/usr/share/premake/?/?.lua\",\n}\npackage.path = table.concat(packagePaths, \";\")\napi.register {\nname = \"architecture\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"universal\",\n\"x32\",\n\"x64\",\n},\n}\napi.register {\nname = \"basedir\",\nscope = \"project\",\nkind = \"path\"\n}\napi.register {\nname = \"buildaction\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Compile\",\n\"Component\",\n\"Copy\",\n\"Embed\",\n\"Form\",\n\"None\",\n\"UserControl\",\n},\n}\napi.register {\nname = \"buildmessage\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}"
	"\napi.register {\nname = \"buildcommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"buildoptions\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"buildoutputs\",\nscope = \"config\",\nkind = \"file-list\",\ntokens = true,\n}\napi.register {\nname = \"buildrule\",     -- DEPRECATED\nscope = \"config\",\nkind = \"object\",\ntokens = true,\n}\napi.register {\nname = \"cleancommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"configmap\",\nscope = \"config\",\nkind = \"key-array\"\n}\napi.register {\nname = \"configurations\",\nscope = \"project\",\nkind = \"string-list\",\n}\napi.register {\nname = \"copylocal\",\nscope = \"config\",\nkind = \"mixed-list\",\ntokens = true,\n}\napi.register {\nname = \"debugargs\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"debugcommand\",\nscope = \"config\",\nkind = \"path\",\ntokens = tr"
	"ue,\n}\napi.register {\nname = \"debugdir\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"debugenvs\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"debugformat\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"c7\",\n},\n}\napi.register {\nname = \"defines\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"dependson\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"deploymentoptions\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\nfunction excludes(value)\nremovefiles(value)\nend\napi.register {\nname = \"filename\",\nscope = \"project\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"files\",\nscope = \"config\",\nkind = \"file-list\",\ntokens = true,\n}\napi.register {\nname = \"flags\",\nscope = \"config\",\nkind  = \"string-list\",\nallowed = {\n\"Component\",           -- DEPRECATED\n\"Deb"
	"ugEnvsDontMerge\",\n\"DebugEnvsInherit\",\n\"EnableSSE\",           -- DEPRECATED\n\"EnableSSE2\",          -- DEPRECATED\n\"ExcludeFromBuild\",\n\"ExtraWarnings\",       -- DEPRECATED\n\"FatalWarnings\",\n\"FloatFast\",           -- DEPRECATED\n\"FloatStrict\",         -- DEPRECATED\n\"LinkTimeOptimization\",\n\"Managed\",\n\"MFC\",\n\"MultiProcessorCompile\",\n\"NativeWChar\",         -- DEPRECATED\n\"No64BitChecks\",\n\"NoCopyLocal\",\n\"NoEditAndContinue\",\n\"NoExceptions\",\n\"NoFramePointer\",\n\"NoImplicitLink\",\n\"NoImportLib\",\n\"NoIncrementalLink\",\n\"NoManifest\",\n\"NoMinimalRebuild\",\n\"NoNativeWChar\",       -- DEPRECATED\n\"NoPCH\",\n\"NoRuntimeChecks\",\n\"NoRTTI\",\n\"NoBufferSecurityCheck\",\n\"NoWarnings\",          -- DEPRECATED\n\"Optimize\",            -- DEPRECATED\n\"OptimizeSize\",        -- DEPRECATED\n\"OptimizeSpeed\",       -- DEPRECATED\n\"ReleaseRuntime\",\n\"SEH\",\n\"StaticRuntime\",\n\"Symbols\",\n\"Unicode\",\n\"Unsafe\",\n\"WinMain\",\n},\naliases = {\nOptimise = 'Optim"
	"ize',\nOptimiseSize = 'OptimizeSize',\nOptimiseSpeed = 'OptimizeSpeed',\n},\n}\napi.register {\nname = \"floatingpoint\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Default\",\n\"Fast\",\n\"Strict\",\n}\n}\napi.register {\nname = \"forceincludes\",\nscope = \"config\",\nkind = \"mixed-list\",\ntokens = true,\n}\napi.register {\nname = \"forceusings\",\nscope = \"config\",\nkind = \"file-list\",\ntokens = true,\n}\napi.register {\nname = \"framework\",\nscope = \"project\",\nkind = \"string\",\nallowed = {\n\"1.0\",\n\"1.1\",\n\"2.0\",\n\"3.0\",\n\"3.5\",\n\"4.0\",\n\"4.5\",\n},\n}\napi.register {\nname = \"icon\",\nscope = \"project\",\nkind = \"file\",\ntokens = true,\n}\napi.register {\nname = \"imageoptions\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"imagepath\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"implibdir\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"imp"
	"libextension\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"implibname\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"implibprefix\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"implibsuffix\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"includedirs\",\nscope = \"config\",\nkind = \"directory-list\",\ntokens = true,\n}\napi.register {\nname = \"kind\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"ConsoleApp\",\n\"Makefile\",\n\"None\",\n\"SharedLib\",\n\"StaticLib\",\n\"WindowedApp\",\n},\n}\napi.register {\nname = \"language\",\nscope = \"project\",\nkind = \"string\",\nallowed = {\n\"C\",\n\"C++\",\n\"C#\",\n},\n}\napi.register {\nname = \"libdirs\",\nscope = \"config\",\nkind = \"directory-list\",\ntokens = true,\n}\napi.register {\nname = \"linkoptions\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.regis"
	"ter {\nname = \"links\",\nscope = \"config\",\nkind = \"mixed-list\",\ntokens = true,\n}\napi.register {\nname = \"location\",\nscope = \"project\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"makesettings\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"namespace\",\nscope = \"project\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"nativewchar\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Default\",\n\"On\",\n\"Off\",\n}\n}\napi.register {\nname = \"objdir\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"optimize\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Off\",\n\"On\",\n\"Debug\",\n\"Size\",\n\"Speed\",\n\"Full\",\n}\n}\napi.register {\nname = \"pchheader\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"pchsource\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"platforms\",\nscope"
	" = \"project\",\nkind = \"string-list\",\n}\napi.register {\nname = \"postbuildcommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"prebuildcommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"prelinkcommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"rebuildcommands\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"resdefines\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"resincludedirs\",\nscope = \"config\",\nkind = \"directory-list\",\ntokens = true,\n}\napi.register {\nname = \"resoptions\",\nscope = \"config\",\nkind = \"string-list\",\ntokens = true,\n}\napi.register {\nname = \"startproject\",\nscope = \"solution\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"system\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"aix\",\n\"bsd\",\n"
	"\"haiku\",\n\"linux\",\n\"macosx\",\n\"ps3\",\n\"solaris\",\n\"wii\",\n\"windows\",\n\"xbox360\",\n},\n}\napi.register {\nname = \"targetdir\",\nscope = \"config\",\nkind = \"path\",\ntokens = true,\n}\napi.register {\nname = \"targetextension\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"targetname\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"targetprefix\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"targetsuffix\",\nscope = \"config\",\nkind = \"string\",\ntokens = true,\n}\napi.register {\nname = \"toolset\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"clang\",\n\"gcc\",\n\"msc\",\n\"snc\",\n},\n}\n api.register {\nname = \"usingdirs\",\nscope = \"config\",\nkind = \"directory-list\",\ntokens = true,\n}\napi.register {\nname = \"uuid\",\nscope = \"project\",\nkind = \"string\",\nallowed = function(value)\nlocal ok = true\nif (#value ~= 36) then ok = false end\nfor i="
	"1,36 do\nlocal ch = value:sub(i,i)\nif (not ch:find(\"[ABCDEFabcdef0123456789-]\")) then ok = false end\nend\nif (value:sub(9,9) ~= \"-\")   then ok = false end\nif (value:sub(14,14) ~= \"-\") then ok = false end\nif (value:sub(19,19) ~= \"-\") then ok = false end\nif (value:sub(24,24) ~= \"-\") then ok = false end\nif (not ok) then\nreturn nil, \"invalid UUID\"\nend\nreturn value:upper()\nend\n}\napi.register {\nname = \"vectorextensions\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Default\",\n\"SSE\",\n\"SSE2\",\n}\n}\napi.register {\nname = \"vpaths\",\nscope = \"project\",\nkind = \"key-path-list\",\n}\napi.register {\nname = \"warnings\",\nscope = \"config\",\nkind = \"string\",\nallowed = {\n\"Off\",\n\"Default\",\n\"Extra\",\n}\n}\napi.deprecateField(\"buildrule\", DOC_URL ..  \"Custom_Build_Commands\",\nfunction(value)\nif value.description then\nbuildmessage(value.description)\nend\nbuildcommands(value.commands)\nbuildoutputs(value.outputs)\nend)\napi.deprecateValue(\"flags\", \"Compone"
	"nt\", DOC_URL .. \"buildaction\",\nfunction(value)\nbuildaction \"Component\"\nend)\napi.deprecateValue(\"flags\", { \"EnableSSE\", \"EnableSSE2\" }, DOC_URL .. \"vectorextensions\",\nfunction(value)\nvectorextensions(value:sub(7))\nend,\nfunction(value)\nvectorextension \"Default\"\nend)\napi.deprecateValue(\"flags\", { \"FloatFast\", \"FloatStrict\" }, DOC_URL ..  \"floatingpoint\",\nfunction(value)\nfloatingpoint(value:sub(6))\nend,\nfunction(value)\nfloatingpoint \"Default\"\nend)\napi.deprecateValue(\"flags\", { \"NativeWChar\", \"NoNativeWChar\" }, DOC_URL .. \"nativewchar\",\nfunction(value)\nlocal map = { NativeWChar = \"On\", NoNativeWChar = \"Off\" }\nnativewchar(map[value] or \"Default\")\nend,\nfunction(value)\nnativewchar \"Default\"\nend)\napi.deprecateValue(\"flags\", { \"Optimize\", \"OptimizeSize\", \"OptimizeSpeed\" }, DOC_URL .. \"optimize\",\nfunction(value)\nlocal map = { Optimize = \"On\", OptimizeSize = \"Size\", OptimizeSpeed = \"Speed\" }\noptimize (map[value] or \"Off\")\nend,\nfuncti"
	"on(value)\noptimize \"Off\"\nend)\napi.deprecateValue(\"flags\", { \"ExtraWarnings\", \"NoWarnings\" }, DOC_URL .. \"warnings\",\nfunction(value)\nlocal map = { ExtraWarnings = \"Extra\", NoWarnings = \"Off\" }\nwarnings (map[value] or \"Default\")\nend,\nfunction(value)\nwarnings \"Default\"\nend)\nnewoption\n{\ntrigger     = \"cc\",\nvalue       = \"VALUE\",\ndescription = \"Choose a C/C++ compiler set\",\nallowed = {\n{ \"clang\", \"Clang (clang)\" },\n{ \"gcc\", \"GNU GCC (gcc/g++)\" },\n}\n}\nnewoption\n{\ntrigger     = \"dotnet\",\nvalue       = \"VALUE\",\ndescription = \"Choose a .NET compiler set\",\nallowed = {\n{ \"msnet\",   \"Microsoft .NET (csc)\" },\n{ \"mono\",    \"Novell Mono (mcs)\"    },\n{ \"pnet\",    \"Portable.NET (cscc)\"  },\n}\n}\nnewoption\n{\ntrigger     = \"file\",\nvalue       = \"FILE\",\ndescription = \"Read FILE as a Premake script; default is 'premake5.lua'\"\n}\nnewoption\n{\ntrigger     = \"help\",\ndescription = \"Display this information\"\n}\nnewoption\n{\ntrigger     = "
	"\"os\",\nvalue       = \"VALUE\",\ndescription = \"Generate files for a different operating system\",\nallowed = {\n{ \"aix\",      \"IBM AIX\" },\n{ \"bsd\",      \"OpenBSD, NetBSD, or FreeBSD\" },\n{ \"haiku\",    \"Haiku\" },\n{ \"hurd\",     \"GNU/Hurd\" },\n{ \"linux\",    \"Linux\" },\n{ \"macosx\",   \"Apple Mac OS X\" },\n{ \"solaris\",  \"Solaris\" },\n{ \"windows\",  \"Microsoft Windows\" },\n}\n}\nnewoption\n{\ntrigger     = \"scripts\",\nvalue       = \"path\",\ndescription = \"Search for additional scripts on the given path\"\n}\nnewoption\n{\ntrigger     = \"systemscript\",\nvalue       = \"FILE\",\ndescription = \"Override default system script (premake5-system.lua)\"\n}\nnewoption\n{\ntrigger     = \"version\",\ndescription = \"Display version information\"\n}\nlanguage \"C++\"\nconfiguration { \"SharedLib\" }\ntargetprefix \"lib\"\ntargetextension \".so\"\nconfiguration { \"StaticLib\" }\ntargetprefix \"lib\"\ntargetextension \".a\"\nconfiguration { \"MacOSX\", \"SharedLib\" }\ntargetextension"
	" \".dylib\"\nconfiguration { \"PS3\", \"ConsoleApp\" }\ntargetextension \".elf\"\nconfiguration { \"Windows or C#\", \"ConsoleApp or WindowedApp\" }\ntargetextension \".exe\"\nconfiguration { \"Xbox360\", \"ConsoleApp or WindowedApp\" }\ntargetextension \".exe\"\nconfiguration { \"Windows or Xbox360 or C#\", \"SharedLib\" }\ntargetprefix \"\"\ntargetextension \".dll\"\nimplibextension \".lib\"\nconfiguration { \"Windows or Xbox360 or C#\", \"StaticLib\" }\ntargetprefix \"\"\ntargetextension \".lib\"\n",

	/* tools/dotnet.lua */
	"premake.tools.dotnet = {}\nlocal dotnet = premake.tools.dotnet\nlocal project = premake.project\nlocal config = premake.config\ndotnet.namestyle = \"windows\"\nfunction dotnet.fileinfo(fcfg)\nlocal info = {}\nlocal fname = fcfg.abspath\nlocal ext = path.getextension(fname):lower()\nif fcfg.buildaction == \"Compile\" or ext == \".cs\" then\ninfo.action = \"Compile\"\nelseif fcfg.buildaction == \"Embed\" or ext == \".resx\" then\ninfo.action = \"EmbeddedResource\"\nelseif fcfg.buildaction == \"Copy\" or ext == \".asax\" or ext == \".aspx\" then\ninfo.action = \"Content\"\nelse\ninfo.action = \"None\"\nend\nif info.action == \"Compile\" and fname:endswith(\".cs\") then\nif fname:endswith(\".Designer.cs\") then\nlocal basename = fname:sub(1, -13)\ntestname = basename .. \".resx\"\nif project.hasfile(fcfg.project, testname) then\ninfo.subtype = \"AutoGenerated\"\ninfo.dependency = testname\nend\nlocal testname = basename .. \".cs\"\nif project.hasfile(fcfg.project, testname) then\ninfo.subtype = \"Dependency\"\ninf"
	"o.dependency = testname\nend\nelse\nlocal basename = fname:sub(1, -4)\ntestname = basename .. \".Designer.cs\"\nif project.hasfile(fcfg.project, testname) then\ninfo.subtype = \"Form\"\nend\nend\nif fcfg.buildaction == \"Component\" or\n   fcfg.buildaction == \"Form\" or\n   fcfg.buildaction == \"UserControl\"\n   then\ninfo.subtype = fcfg.buildaction\nend\nif fcfg.flags and fcfg.flags.Component then\ninfo.subtype = \"Component\"\nend\nend\nif info.action == \"EmbeddedResource\" and fname:endswith(\".resx\") then\nlocal basename = fname:sub(1, -6)\nlocal testname = basename .. \".cs\"\nif project.hasfile(fcfg.project, testname) then\ninfo.dependency = testname\nif project.hasfile(fcfg.project, basename .. \".Designer.cs\") then\ninfo.subtype = \"DesignerType\"\nend\nelse\ntestname = basename .. \".Designer.cs\"\nif project.hasfile(fcfg.project, testname) then\ninfo.subtype = \"Designer\"\nend\nend\nend\nif info.action == \"Content\" then\ninfo.subtype = \"PreserveNewest\"\nend\nreturn info\nend\nfunction dotne"
	"t.gettoolname(cfg, tool)\nlocal compilers = {\nmsnet = \"csc\",\nmono = \"mcs\",\npnet = \"cscc\",\n}\nif tool == \"csc\" then\nlocal toolset = _OPTIONS.dotnet or iif(os.is(premake.WINDOWS), \"msnet\", \"mono\")\nreturn compilers[toolset]\nelse\nreturn \"resgen\"\nend\nend\ndotnet.flags = {\nflags = {\nFatalWarning = \"/warnaserror\",\nSymbols = \"/debug\",\nUnsafe = \"/unsafe\"\n},\noptimize = {\nOn = \"/optimize\",\nSize = \"/optimize\",\nSpeed = \"/optimize\",\n},\n}\nfunction dotnet.getflags(cfg)\nlocal flags = config.mapFlags(cfg, dotnet.flags)\ntable.insert(flags, '/noconfig')\nif cfg.project.icon then\nlocal fn = project.getrelative(cfg.project, cfg.project.icon)\ntable.insert(flags, string.format('/win32icon:\"%s\"', fn))\nend\nif #cfg.defines > 0 then\ntable.insert(flags, table.implode(cfg.defines, \"/d:\", \"\", \" \"))\nend\nreturn table.join(flags, cfg.buildoptions)\nend\nfunction dotnet.getkind(cfg)\nif (cfg.kind == \"ConsoleApp\") then\nreturn \"Exe\"\nelseif (cfg.kind == \"WindowedApp\") then\nr"
	"eturn \"WinExe\"\nelseif (cfg.kind == \"SharedLib\") then\nreturn \"Library\"\nend\nend\nfunction dotnet.getmakesettings(cfg)\nreturn nil\nend\n",

	/* tools/gcc.lua */
	"premake.tools.gcc = {}\nlocal gcc = premake.tools.gcc\nlocal project = premake.project\nlocal config = premake.config\ngcc.sysflags = {\nhaiku = {\ncppflags = \"-MMD\"\n},\nps3 = {\ncc = \"ppu-lv2-g++\",\ncxx = \"ppu-lv2-g++\",\nar = \"ppu-lv2-ar\",\n},\nuniversal = {\ncppflags = \"\",  -- block default -MMD -MP flags\n},\nwii = {\ncppflags = \"-MMD -MP -I$(LIBOGC_INC) $(MACHDEP)\",\ncfgsettings = [[\n  ifeq ($(strip $(DEVKITPPC)),)\n    $(error \"DEVKITPPC environment variable is not set\")'\n  endif\n  include $(DEVKITPPC)/wii_rules']],\n},\n}\nfunction gcc.getsysflags(cfg, field)\nlocal result = {}\nlocal system = gcc.sysflags[cfg.system]\nif system then\nresult = table.join(result, system[field])\nend\nlocal arch = gcc.sysflags[cfg.architecture]\nif arch then\nresult = table.join(result, arch[field])\nend\nreturn result\nend\nfunction gcc.getcppflags(cfg)\nlocal flags = gcc.getsysflags(cfg, 'cppflags')\nif #flags == 0 then\nflags = { \"-MMD\", \"-MP\" }\nend\nreturn flags\nend\ngcc.cflags = {\narchitecture"
	" = {\nx32 = \"-m32\",\nx64 = \"-m64\",\n},\nflags = {\nFatalWarnings = \"-Werror\",\nNoFramePointer = \"-fomit-frame-pointer\",\nSymbols = \"-g\"\n},\nfloatingpoint = {\nFast = \"-ffast-math\",\nStrict = \"-ffloat-store\",\n},\noptimize = {\nOff = \"-O0\",\nOn = \"-O2\",\nDebug = \"-Og\",\nFull = \"-O3\",\nSize = \"-Os\",\nSpeed = \"-O3\",\n},\nvectorextensions = {\nSSE = \"-msse\",\nSSE2 = \"-msse2\",\n},\nwarnings = {\nExtra = \"-Wall -Wextra\",\nOff = \"-w\",\n}\n}\nfunction gcc.getcflags(cfg)\nlocal flags = config.mapFlags(cfg, gcc.cflags)\nif cfg.system ~= premake.WINDOWS and cfg.kind == premake.SHAREDLIB then\ntable.insert(flags, \"-fPIC\")\nend\nreturn flags\nend\ngcc.cxxflags = {\nNoExceptions   = \"-fno-exceptions\",\nNoRTTI         = \"-fno-rtti\",\nNoBufferSecurityCheck = \"-fno-stack-protector\"\n}\nfunction gcc.getcxxflags(cfg)\nlocal flags = table.translate(cfg.flags, gcc.cxxflags)\nreturn flags\nend\nfunction gcc.getdefines(defines)\nlocal result = {}\nfor _, define in ipairs(defines) do\ntable."
	"insert(result, '-D' .. define)\nend\nreturn result\nend\nfunction gcc.getforceincludes(cfg)\nlocal result = {}\ntable.foreachi(cfg.forceincludes, function(value)\nlocal fn = project.getrelative(cfg.project, value)\ntable.insert(result, string.format('-include %s', premake.quoted(fn)))\nend)\nreturn result\nend\nfunction gcc.getincludedirs(cfg, dirs)\nlocal result = {}\nfor _, dir in ipairs(dirs) do\ndir = project.getrelative(cfg.project, dir)\ntable.insert(result, '-I' .. premake.quoted(dir))\nend\nreturn result\nend\ngcc.ldflags = {\narchitecture = {\nx32 = { \"-m32\", \"-L/usr/lib32\" },\nx64 = { \"-m64\", \"-L/usr/lib64\" },\n},\nsystem = {\nwii = { \"-L$(LIBOGC_LIB)\", \"$(MACHDEP)\" },\n}\n}\nfunction gcc.getldflags(cfg)\nlocal flags = {}\nfor _, dir in ipairs(config.getlinks(cfg, \"system\", \"directory\")) do\ntable.insert(flags, '-L' .. project.getrelative(cfg.project, dir))\nend\nif not cfg.flags.Symbols then\nif cfg.system == premake.MACOSX then\ntable.insert(flags, \"-Wl,-x\")\nelse\ntable.insert(fl"
	"ags, \"-s\")\nend\nend\nif cfg.kind == premake.SHAREDLIB then\nif cfg.system == premake.MACOSX then\ntable.insert(flags, \"-dynamiclib\")\nelse\ntable.insert(flags, \"-shared\")\nend\nif cfg.system == \"windows\" and not cfg.flags.NoImportLib then\ntable.insert(flags, '-Wl,--out-implib=\"' .. cfg.linktarget.relpath .. '\"')\nend\nend\nif cfg.kind == premake.WINDOWEDAPP and cfg.system == premake.WINDOWS then\ntable.insert(flags, \"-mwindows\")\nend\nreturn table.join(flags, config.mapFlags(cfg, gcc.ldflags))\nend\nfunction gcc.getlinks(cfg, systemonly)\nlocal result = {}\nif not systemonly then\nresult = config.getlinks(cfg, \"siblings\", \"fullpath\")\nend\nlocal links = config.getlinks(cfg, \"system\", \"fullpath\")\nfor _, link in ipairs(links) do\nif path.isframework(link) then\ntable.insert(result, \"-framework \" .. path.getbasename(link))\nelseif path.isobjectfile(link) then\ntable.insert(result, link)\nelse\ntable.insert(result, \"-l\" .. path.getbasename(link))\nend\nend\nreturn result\nend\nfunction g"
	"cc.getmakesettings(cfg)\nlocal sysflags = gcc.sysflags[cfg.architecture] or gcc.sysflags[cfg.system] or {}\nreturn sysflags.cfgsettings\nend\nfunction gcc.gettoolname(cfg, tool)\nif tool == \"rc\" then\nreturn \"windres\"\nend\nlocal sysflags = gcc.sysflags[cfg.architecture] or gcc.sysflags[cfg.system] or {}\nreturn sysflags[tool]\nend\n",

	/* tools/msc.lua */
	"premake.tools.msc = {}\nlocal msc = premake.tools.msc\nlocal project = premake.project\nlocal config = premake.config\nfunction msc.getcppflags(cfg)\nreturn {}\nend\nmsc.cflags = {\nflags = {\nSEH = \"/EHa\",\nSymbols = \"/Z7\",\n},\noptimize = {\nOff = \"/Od\",\nOn = \"/Ot\",\nDebug = \"/Od\",\nFull = \"/Ox\",\nSize = \"/O1\",\nSpeed = \"/O2\",\n}\n}\nfunction msc.getcflags(cfg)\nlocal flags = config.mapFlags(cfg, msc.cflags)\nlocal runtime = iif(cfg.flags.StaticRuntime, \"/MT\", \"/MD\")\nif config.isDebugBuild(cfg) then\nruntime = runtime .. \"d\"\nend\ntable.insert(flags, runtime)\nif not cfg.flags.SEH then\ntable.insert(flags, \"/EHsc\")\nend\nreturn flags\nend\nmsc.cxxflags = {\n}\nfunction msc.getcxxflags(cfg)\nreturn table.translate(cfg.flags, msc.cxxflags)\nend\nmsc.ldflags = {\nSymbols = \"/DEBUG\",\n}\nfunction msc.getdefines(defines)\nlocal result = {}\nfor _, define in ipairs(defines) do\ntable.insert(result, '-D' .. define)\nend\nreturn result\nend\nfunction msc.getforceincludes(cfg)\nlocal resul"
	"t = {}\ntable.foreachi(cfg.forceincludes, function(value)\nlocal fn = project.getrelative(cfg.project, value)\ntable.insert(result, \"/FI\" .. premake.quoted(fn))\nend)\nreturn result\nend\nfunction msc.getincludedirs(cfg, dirs)\nlocal result = {}\nfor _, dir in ipairs(dirs) do\ndir = project.getrelative(cfg.project, dir)\ntable.insert(result, '-I' ..  premake.quoted(dir))\nend\nreturn result\nend\nmsc.ldflags = {\nSymbols = \"/DEBUG\",\n}\nfunction msc.getldflags(cfg)\nlocal flags = table.translate(cfg.flags, msc.ldflags)\nif not cfg.flags.NoManifest and cfg.kind ~= premake.STATICLIB then\ntable.insert(flags, \"/MANIFEST\")\nend\nif config.isOptimizedBuild(cfg) then\ntable.insert(flags, \"/OPT:REF /OPT:ICF\")\nend\nfor _, libdir in ipairs(project.getrelative(cfg.project, cfg.libdirs)) do\ntable.insert(flags, '/LIBPATH:\"' .. libdir .. '\"')\nend\nreturn flags\nend\nfunction msc.getlinks(cfg)\nlocal links = config.getlinks(cfg, \"system\", \"fullpath\")\nreturn links\nend\nfunction msc.getmakesettings(cfg)\nre"
	"turn nil\nend\nfunction msc.gettoolname(cfg, tool)\nreturn nil\nend\n",

	/* tools/snc.lua */
	"premake.tools.snc = {}\nlocal snc = premake.tools.snc\nlocal gcc = premake.tools.gcc\nlocal config = premake.config\nsnc.sysflags = {}\nsnc.cflags = {\nflags = {\nFatalWarnings = \"-Xquit=2\",\n},\noptimize = {\nOff = \"-O0\",\nOn = \"-O1\",\nDebug = \"-Od\",\nFull = \"-O3\",\nSize = \"-Os\",\nSpeed = \"-O2\",\n},\nwarnings = {\nExtra = \"-Xdiag=2\",\n}\n}\nfunction snc.getcflags(cfg)\nlocal flags = config.mapFlags(cfg, snc.cflags)\nreturn flags\nend\nsnc.cxxflags = {\nNoExceptions   = \"-Xc-=exceptions\",\nNoRTTI         = \"-Xc-=rtti\",\n}\nfunction snc.getcxxflags(cfg)\nlocal flags = table.translate(cfg.flags, snc.cxxflags)\nif not cfg.flags.NoExceptions then\ntable.insert(flags, \"-Xc+=exceptions\")\nend\nif not cfg.flags.NoRTTI then\ntable.insert(flags, \"-Xc+=rtti\")\nend\nreturn flags\nend\nfunction snc.getforceincludes(cfg)\nlocal flags = gcc.getforceincludes(cfg)\nreturn flags\nend\nfunction snc.getldflags(cfg)\nlocal flags = { }\nif not cfg.flags.Symbols then\ntable.insert(flags, \"-s\")\nend\nreturn"
	" flags\nend\nsnc.getcppflags = gcc.getcppflags\nsnc.getdefines = gcc.getdefines\nsnc.getincludedirs = gcc.getincludedirs\nsnc.getlinks = gcc.getlinks\nfunction snc.getmakesettings(cfg)\nreturn nil\nend\nfunction snc.gettoolname(cfg, tool)\nlocal sysflags = snc.sysflags[cfg.architecture] or snc.sysflags[cfg.system] or {}\nreturn sysflags[tool]\nend\n",

	/* tools/clang.lua */
	"premake.tools.clang = {}\nlocal clang = premake.tools.clang\nlocal gcc = premake.tools.gcc\nfunction clang.getcppflags(cfg)\nlocal flags = gcc.getcppflags(cfg)\nreturn flags\nend\nfunction clang.getcflags(cfg)\nlocal flags = gcc.getcflags(cfg)\nreturn flags\nend\nfunction clang.getcxxflags(cfg)\nlocal flags = gcc.getcxxflags(cfg)\nreturn flags\nend\nfunction clang.getdefines(defines)\nlocal flags = gcc.getdefines(defines)\nreturn flags\nend\nfunction clang.getforceincludes(cfg)\nlocal flags = gcc.getforceincludes(cfg)\nreturn flags\nend\nfunction clang.getincludedirs(cfg, dirs)\nlocal flags = gcc.getincludedirs(cfg, dirs)\nreturn flags\nend\nfunction clang.getldflags(cfg)\nlocal flags = gcc.getldflags(cfg)\nreturn flags\nend\nfunction clang.getlinks(cfg, systemOnly)\nlocal flags = gcc.getlinks(cfg, systemOnly)\nreturn flags\nend\nfunction clang.getmakesettings(cfg)\nlocal flags = gcc.getmakesettings(cfg)\nreturn flags\nend\nfunction clang.gettoolname(cfg, tool)\nif tool == \"ar\" then\nreturn \"ar\"\nelseif to"
	"ol == \"cc\" then\nreturn \"clang\"\nelseif tool == \"cxx\" then\nreturn \"clang++\"\nend\nend\n",

	/* packages/gtk.lua */
	"premake.packages.gtk = {}\nfunction premake.packages.gtk.config(pkg)\nif(not pkg.nodefines) then\ndefines { \"GTK_COMPILATION\" }\nend\nif(not pkg.noincludedirs) then\nif(not findin(configuration().includedirs, \"gtk/gtk.h\")) then\nlocal s = findin(configuration().includedirs, \"gtk-3.0/gtk/gtk.h\")\nif(not s) then print(\"Warning: \\\"gtk/gtk.h\\\" not found\")\nelse includedirs { path.getabsolute(path.join(s, \"gtk-3.0/\")) }\nend\nend\nif(not findin(configuration().includedirs, \"gdk-pixbuf/gdk-pixbuf.h\")) then\nlocal s = findin(configuration().includedirs, \"gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf.h\")\nif(not s) then print(\"Warning: \\\"gdk-pixbuf/gdk-pixbuf.h\\\" not found\")\nelse includedirs { path.getabsolute(path.join(s, \"gdk-pixbuf-2.0/\")) }\nend\nend\nend\nif(not pkg.nolinks) then\nif(_OPTIONS[\"os\"] == \"linux\") then\nlinks { \"gtk-3\", \"gdk-3\", \"gdk_pixbuf-2.0\" }\nelseif(_OPTIONS[\"os\"] == \"windows\" and _OPTIONS[\"platform\"] == \"x32\") then\nlinks { \"gtk-win32-3.0\", \"gdk-win32-3.0"
	"\" }\nelseif(_OPTIONS[\"os\"] == \"windows\" and _OPTIONS[\"platform\"] == \"x64\") then\nlinks { \"gtk-win64-3.0\", \"gdk-win64-3.0\" }\nend\nend\nif(not pkg.nodepends) then\nusing { name =  \"glib\" }\nusing { name = \"pango\" }\nusing { name = \"cairo\" }\nusing { name =   \"atk\" }\nend\nend\n",

	/* packages/glib.lua */
	"premake.packages.glib = {}\nfunction premake.packages.glib.config(pkg)\nif(not pkg.noincludedirs) then\nif(not findin(configuration().includedirs, \"glib.h\")) then\nlocal s = findin(configuration().includedirs, \"glib-2.0/glib.h\")\nif(not s) then print(\"Warning: \\\"glib.h\\\" not found\") end\nincludedirs { path.join(s, \"glib-2.0/\") }\nend\nif(not findin(configuration().includedirs, \"glibconfig.h\")) then\nlocal s = findin(configuration().libdirs, \"glib-2.0/include/glibconfig.h\")\nif(not s) then print(\"Warning: \\\"glibconfig.h\\\" not found\") end\nincludedirs { path.join(s, \"glib-2.0/include/\") }\nend\nend\nif(not pkg.nolinks) then\nlinks { 'glib-2.0', 'gobject-2.0' }\nend\nend\n",

	/* packages/pango.lua */
	"premake.packages.pango = {}\nfunction premake.packages.pango.config(pkg)\nif(not pkg.noincludedirs) then\nif(not findin(configuration().includedirs, \"pango/pango.h\")) then\nlocal s = findin(configuration().includedirs, \"pango-1.0/pango/pango.h\")\nif(not s) then print(\"Warning: \\\"pango/pango.h\\\" not found\") end\nincludedirs { path.join(s, \"pango-1.0/\") }\nend\nend\nif(not pkg.nolinks) then\nlinks { 'pango-1.0' }\nend\nend\n",

	/* packages/cairo.lua */
	"premake.packages.cairo = {}\nfunction premake.packages.cairo.config(pkg)\nif(not pkg.noincludedirs) then\nif(not findin(configuration().includedirs, \"cairo.h\")) then\nlocal s = findin(configuration().includedirs, \"cairo/cairo.h\")\nif(not s) then print(\"Warning: \\\"cairo.h\\\" not found\") end\nincludedirs { path.join(s, \"cairo/\") }\nend\nend\nif(not pkg.nolinks) then\nlinks { 'cairo' }\nend\nend\n",

	/* packages/atk.lua */
	"premake.packages.atk = {}\nfunction premake.packages.atk.config(pkg)\nif(not pkg.noincludedirs) then\nif(not findin(configuration().includedirs, \"atk/atk.h\")) then\nlocal s = findin(configuration().includedirs, \"atk-1.0/atk/atk.h\")\nif(not s) then print(\"Warning: \\\"atk/atk.h\\\" not found\") end\nincludedirs { path.join(s, \"atk-1.0/\") }\nend\nend\nif(not pkg.nolinks) then\nlinks { \"atk-1.0\" }\nend\nend\n",

	/* actions/make/_make.lua */
	"premake.make = {}\nlocal make = premake.make\nlocal solution = premake.solution\nlocal project = premake.project\nnewaction {\ntrigger         = \"gmake\",\nshortname       = \"GNU Make\",\ndescription     = \"Generate GNU makefiles for POSIX, MinGW, and Cygwin\",\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"clang\", \"gcc\" },\ndotnet = { \"mono\", \"msnet\", \"pnet\" }\n},\nonsolution = function(sln)\nio.esc = make.esc\npremake.generate(sln, make.getmakefilename(sln, false), make.generate_solution)\nend,\nonproject = function(prj)\nio.esc = make.esc\nlocal makefile = make.getmakefilename(prj, true)\nif project.isdotnet(prj) then\npremake.generate(prj, makefile, make.cs.generate)\nelse\npremake.generate(prj, makefile, make.cpp.generate)\nend\nend,\noncleansolution = function(sln)\npremake.clean.file(sln, make.getmakefilename(sln, false))\nend,\noncleanproject = function(prj)\npremake.clea"
	"n.file(prj, make.getmakefilename(prj, true))\nend\n}\nfunction make.defaultconfig(target)\nlocal eachconfig = iif(target.project, project.eachconfig, solution.eachconfig)\nlocal iter = eachconfig(target)\nlocal cfg = iter()\nif cfg then\n_p('ifndef config')\n_x('  config=%s', cfg.shortname)\n_p('endif')\n_p('')\nend\nend\nfunction make.esc(value)\nresult = value:gsub(\"\\\\\", \"\\\\\\\\\")\nresult = result:gsub(\" \", \"\\\\ \")\nresult = result:gsub(\"%(\", \"\\\\%(\")\nresult = result:gsub(\"%)\", \"\\\\%)\")\nresult = result:gsub(\"$\\\\%((.-)\\\\%)\", \"$%(%1%)\")\nreturn result\nend\nfunction make.getmakefilename(this, searchprjs)\nlocal count = 0\nfor sln in premake.solution.each() do\nif sln.location == this.location then\ncount = count + 1\nend\nif searchprjs then\nfor _, prj in ipairs(sln.projects) do\nif prj.location == this.location then\ncount = count + 1\nend\nend\nend\nend\nif count == 1 then\nreturn \"Makefile\"\nelse\nreturn \".make\"\nend\nend\nfunction make.header(target)\nlocal kind = iif(t"
	"arget.project, \"project\", \"solution\")\n_p('# %s %s makefile autogenerated by Premake', premake.action.current().shortname, kind)\n_p('')\nmake.defaultconfig(target)\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\nend\nfunction make.mkdirRules(dirname)\n_p('%s:', dirname)\n_p('\\t@echo Creating %s', dirname)\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) mkdir -p %s', dirname)\n_p('else')\n_p('\\t$(SILENT) mkdir $(subst /,\\\\\\\\,%s)', dirname)\n_p('endif')\n_p('')\nend\nfunction make.list(value)\nif #value > 0 then\nreturn \" \" .. table.concat(value, \" \")\nelse\nreturn \"\"\nend\nend\nfunction make.tovar(value)\nvalue = value:gsub(\"[ -]\", \"_\")\nvalue = value:gsub(\"[()]\", \"\")\nreturn value\nend\nfunction make.objdir(cfg)\n_x('  OBJDIR = %s', project.getrelative(cfg.project, cfg.objdir))\nend\nfunction make.objDirRules(prj)\nmake.mkdirRules(\"$(OBJDIR)\")\nend\nfunction make.phonyRules(prj)\n_p('.PHONY: clean prebuild prelink')\n_p('')\nend\nfunction make.preBuildCmds(cfg, too"
	"lset)\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\nend\nfunction make.preBuildRules(prj)\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\nend\nfunction make.preLinkCmds(cfg, toolset)\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\nend\nfunction make.preLinkRules(prj)\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\nend\nfunction make.postBuildCmds(cfg, toolset)\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\nend\nfunction make.settings(cfg, toolset)\nif #cfg.makesettings > 0 then\nfor _, value in ipairs(cfg.makesettings) do\n_p(value)\nend\nend\nloca"
	"l value = toolset.getmakesettings(cfg)\nif value then\n_p(value)\nend\nend\nfunction make.shellType()\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('')\nend\nfunction make.target(cfg)\n_x('  TARGETDIR = %s', project.getrelative(cfg.project, cfg.buildtarget.directory))\n_x('  TARGET = $(TARGETDIR)/%s', cfg.buildtarget.name)\nend\nfunction make.targetDirRules(prj)\nmake.mkdirRules(\"$(TARGETDIR)\")\nend\n",

	/* actions/make/make_solution.lua */
	"local make = premake.make\nlocal solution = premake.solution\nlocal project = premake.project\nfunction make.generate_solution(sln)\nmake.header(sln)\nmake.configmap(sln)\nmake.projects(sln)\n_p('.PHONY: all clean help $(PROJECTS)')\n_p('')\n_p('all: $(PROJECTS)')\n_p('')\nmake.projectrules(sln)\nmake.cleanrules(sln)\nmake.helprule(sln)\nend\nfunction make.configmap(sln)\nfor cfg in solution.eachconfig(sln) do\n_p('ifeq ($(config),%s)', cfg.shortname)\nfor prj in solution.eachproject(sln) do\nlocal prjcfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)\nif prjcfg then\n_p('  %s_config = %s', make.tovar(prj.name), prjcfg.shortname)\nend\nend\n_p('endif')\nend\n_p('')\nend\nfunction make.cleanrules(sln)\n_p('clean:')\nfor prj in solution.eachproject(sln) do\nlocal prjpath = project.getfilename(prj, make.getmakefilename(prj, true))\nlocal prjdir = path.getdirectory(path.getrelative(sln.location, prjpath))\nlocal prjname = path.getname(prjpath)\n_x(1,'@${MAKE} --no-print-directory -C %s -f %s clean', prjdir, "
	"prjname)\nend\n_p('')\nend\nfunction make.helprule(sln)\n_p('help:')\n_p(1,'@echo \"Usage: make [config=name] [target]\"')\n_p(1,'@echo \"\"')\n_p(1,'@echo \"CONFIGURATIONS:\"')\nfor cfg in solution.eachconfig(sln) do\n_x(1, '@echo \"  %s\"', cfg.shortname)\nend\n_p(1,'@echo \"\"')\n_p(1,'@echo \"TARGETS:\"')\n_p(1,'@echo \"   all (default)\"')\n_p(1,'@echo \"   clean\"')\nfor prj in solution.eachproject(sln) do\n_p(1,'@echo \"   %s\"', prj.name)\nend\n_p(1,'@echo \"\"')\n_p(1,'@echo \"For more information, see http://industriousone.com/premake/quick-start\"')\nend\nfunction make.projects(sln)\n_p('PROJECTS := %s', table.concat(premake.esc(table.extract(sln.projects, \"name\")), \" \"))\n_p('')\nend\nfunction make.projectrules(sln)\nfor prj in solution.eachproject(sln) do\nlocal deps = project.getdependencies(prj)\ndeps = table.extract(deps, \"name\")\n_p('%s: %s', premake.esc(prj.name), table.concat(deps, \" \"))\nlocal cfgvar = make.tovar(prj.name)\n_p('ifneq (,$(%s_config))', cfgvar)\n_p(1,'@echo \"==== Bui"
	"lding %s ($(%s_config)) ====\"', prj.name, cfgvar)\nlocal prjpath = project.getfilename(prj, make.getmakefilename(prj, true))\nlocal prjdir = path.getdirectory(path.getrelative(sln.location, prjpath))\nlocal prjname = path.getname(prjpath)\n_x(1,'@${MAKE} --no-print-directory -C %s -f %s config=$(%s_config)', prjdir, prjname, cfgvar)\n_p('endif')\n_p('')\nend\nend\n",

	/* actions/make/make_cpp.lua */
	"premake.make.cpp = {}\nlocal make = premake.make\nlocal cpp = premake.make.cpp\nlocal project = premake.project\nlocal config = premake.config\nlocal fileconfig = premake.fileconfig\ncpp.elements = {}\ncpp.elements.makefile = {\n\"header\",\n\"phonyRules\",\n\"cppConfigs\",\n\"cppObjects\",\n\"shellType\",\n\"cppTargetRules\",\n\"targetDirRules\",\n\"objDirRules\",\n\"cppCleanRules\",\n\"preBuildRules\",\n\"preLinkRules\",\n\"pchRules\",\n\"cppFileRules\",\n\"cppDependencies\",\n}\nfunction make.cpp.generate(prj)\npremake.callarray(make, cpp.elements.makefile, prj)\nend\ncpp.elements.configuration = {\n\"cppTools\",\n\"target\",\n\"objdir\",\n\"pch\",\n\"defines\",\n\"includes\",\n\"forceInclude\",\n\"cppFlags\",\n\"cFlags\",\n\"cxxFlags\",\n\"resFlags\",\n\"libs\",\n\"ldDeps\",\n\"ldFlags\",\n\"linkCmd\",\n\"preBuildCmds\",\n\"preLinkCmds\",\n\"postBuildCmds\",\n\"cppAllRules\",\n\"settings\",\n}\nfunction make.cppConfigs(prj)\nfor cfg in project.eachconfig(prj) do\nlocal toolset = premake.tools[cfg.toolset o"
	"r \"gcc\"]\nif not toolset then\nerror(\"Invalid toolset '\" + cfg.toolset + \"'\")\nend\n_x('ifeq ($(config),%s)', cfg.shortname)\npremake.callarray(make, cpp.elements.configuration, cfg, toolset)\n_p('endif')\n_p('')\nend\nend\nfunction cpp.buildcommand(prj, objext, node)\nlocal iscfile = node and path.iscfile(node.abspath) or false\nlocal flags = iif(prj.language == \"C\" or iscfile, '$(CC) $(ALL_CFLAGS)', '$(CXX) $(ALL_CXXFLAGS)')\n_p('\\t$(SILENT) %s $(FORCE_INCLUDE) -o \"$@\" -MF $(@:%%.%s=%%.d) -c \"$<\"', flags, objext)\nend\nfunction make.cppFileRules(prj)\nlocal tr = project.getsourcetree(prj)\npremake.tree.traverse(tr, {\nonleaf = function(node, depth)\nlocal rules\nfor cfg in project.eachconfig(prj) do\nlocal filecfg = fileconfig.getconfig(node, cfg)\nif fileconfig.hasCustomBuildRule(filecfg) then\nrules = true\nbreak\nend\nend\nif rules then\ncpp.customFileRules(prj, node)\nelse\ncpp.standardFileRules(prj, node)\nend\nend\n})\n_p('')\nend\nfunction cpp.standardFileRules(prj, node)\nif path.iscppfi"
	"le(node.abspath) then\n_x('$(OBJDIR)/%s.o: %s', node.objname, node.relpath)\n_p('\\t@echo $(notdir $<)')\ncpp.buildcommand(prj, \"o\", node)\nelseif path.isresourcefile(node.abspath) then\n_x('$(OBJDIR)/%s.res: %s', node.objname, node.relpath)\n_p('\\t@echo $(notdir $<)')\n_p('\\t$(SILENT) $(RESCOMP) $< -O coff -o \"$@\" $(ALL_RESFLAGS)')\nend\nend\nfunction cpp.customFileRules(prj, node)\nfor cfg in project.eachconfig(prj) do\nlocal filecfg = fileconfig.getconfig(node, cfg)\nif filecfg then\n_x('ifeq ($(config),%s)', cfg.shortname)\nlocal output = project.getrelative(prj, filecfg.buildoutputs[1])\n_x('%s: %s', output, filecfg.relpath)\n_p('\\t@echo \"%s\"', filecfg.buildmessage or (\"Building \" .. filecfg.relpath))\nfor _, cmd in ipairs(filecfg.buildcommands) do\n_p('\\t$(SILENT) %s', cmd)\nend\n_p('endif')\nend\nend\nend\nfunction make.cppObjects(prj)\nlocal root = { objects={}, resources={} }\nlocal configs = {}\nfor cfg in project.eachconfig(prj) do\nconfigs[cfg] = { objects={}, resources={} }\nend\nlocal"
	" tr = project.getsourcetree(prj)\npremake.tree.traverse(tr, {\nonleaf = function(node, depth)\nlocal incfg = {}\nlocal inall = true\nlocal custom = false\nfor cfg in project.eachconfig(prj) do\nlocal filecfg = fileconfig.getconfig(node, cfg)\nif filecfg and not filecfg.flags.ExcludeFromBuild then\nincfg[cfg] = filecfg\ncustom = fileconfig.hasCustomBuildRule(filecfg)\nelse\ninall = false\nend\nend\nif not custom then\nlocal kind\nif path.iscppfile(node.abspath) then\nkind = \"objects\"\nelseif path.isresourcefile(node.abspath) then\nkind = \"resources\"\nend\nif not custom and not kind then\nreturn\nend\nobjectname = \"$(OBJDIR)/\" .. node.objname .. iif(kind == \"objects\", \".o\", \".res\")\nif inall then\ntable.insert(root[kind], objectname)\nelse\nfor cfg in project.eachconfig(prj) do\nif incfg[cfg] then\ntable.insert(configs[cfg][kind], objectname)\nend\nend\nend\nelse\nfor cfg in project.eachconfig(prj) do\nlocal filecfg = incfg[cfg]\nif filecfg then\nlocal output = project.getrelative(prj, filecfg.buildo"
	"utputs[1])\nif path.isobjectfile(output) then\ntable.insert(configs[cfg].objects, output)\nend\nend\nend\nend\nend\n})\nfunction listobjects(var, list)\n_p('%s \\\\', var)\nfor _, objectname in ipairs(list) do\n_x('\\t%s \\\\', objectname)\nend\n_p('')\nend\nlistobjects('OBJECTS :=', root.objects, 'o')\nlistobjects('RESOURCES :=', root.resources, 'res')\nfor cfg in project.eachconfig(prj) do\nlocal files = configs[cfg]\nif #files.objects > 0 or #files.resources > 0 then\n_x('ifeq ($(config),%s)', cfg.shortname)\nif #files.objects > 0 then\nlistobjects('  OBJECTS +=', files.objects)\nend\nif #files.resources > 0 then\nlistobjects('  RESOURCES +=', files.resources)\nend\n_p('endif')\n_p('')\nend\nend\nend\nfunction make.cFlags(cfg, toolset)\n_p('  ALL_CFLAGS += $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(toolset.getcflags(cfg), cfg.buildoptions)))\nend\nfunction make.cppAllRules(cfg, toolset)\nif cfg.system == premake.MACOSX and cfg.kind == premake.WINDOWEDAPP then\n_p('all: $(TARGETDIR) $(OBJDIR)"
	" prebuild prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist')\n_p('\\t@:')\n_p('')\n_p('$(dir $(TARGETDIR))PkgInfo:')\n_p('$(dir $(TARGETDIR))Info.plist:')\nelse\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild prelink $(TARGET)')\n_p('\\t@:')\nend\nend\nfunction make.cppFlags(cfg, toolset)\n_p('  ALL_CPPFLAGS += $(CPPFLAGS)%s $(DEFINES) $(INCLUDES)', make.list(toolset.getcppflags(cfg)))\nend\nfunction make.cxxFlags(cfg, toolset)\n_p('  ALL_CXXFLAGS += $(CXXFLAGS) $(ALL_CFLAGS)%s', make.list(toolset.getcxxflags(cfg)))\nend\nfunction make.cppCleanRules(prj)\n_p('clean:')\n_p('\\t@echo Cleaning %s', prj.name)\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f  $(TARGET)')\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGET)) del $(subst /,\\\\\\\\,$(TARGET))')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\nend\nfunction make.cppDependencies(prj)\n_p('-include $(O"
	"BJECTS:%%.o=%%.d)')\n_p('ifneq (,$(PCH))')\n_p('  -include $(OBJDIR)/$(notdir $(PCH)).d')\n_p('endif')\nend\nfunction make.cppTargetRules(prj)\n_p('$(TARGET): $(GCH) $(OBJECTS) $(LDDEPS) $(RESOURCES)')\n_p('\\t@echo Linking %s', prj.name)\n_p('\\t$(SILENT) $(LINKCMD)')\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\nend\nfunction make.cppTools(cfg, toolset)\nlocal tool = toolset.gettoolname(cfg, \"cc\")\nif tool then\n_p('  CC = %s', tool)\nend\ntool = toolset.gettoolname(cfg, \"cxx\")\nif tool then\n_p('  CXX = %s', tool)\nend\ntool = toolset.gettoolname(cfg, \"ar\")\nif tool then\n_p('  AR = %s', tool)\nend\nend\nfunction make.defines(cfg, toolset)\n_p('  DEFINES +=%s', make.list(toolset.getdefines(cfg.defines)))\nend\nfunction make.forceInclude(cfg, toolset)\nlocal includes = toolset.getforceincludes(cfg)\nif not cfg.flags.NoPCH and cfg.pchheader then\ntable.insert(includes, \"-include $(OBJDIR)/$(notdir $(PCH))\")\nend\n_x('  FORCE_INCLUDE +=%s', make.list(includes))\nend\nfunction make.includes(cfg, toolset)\nlocal i"
	"ncludes = premake.esc(toolset.getincludedirs(cfg, cfg.includedirs))\n_p('  INCLUDES +=%s', make.list(includes))\nend\nfunction make.ldDeps(cfg, toolset)\nlocal deps = config.getlinks(cfg, \"siblings\", \"fullpath\")\n_p('  LDDEPS +=%s', make.list(premake.esc(deps)))\nend\nfunction make.ldFlags(cfg, toolset)\n_p('  ALL_LDFLAGS += $(LDFLAGS)%s', make.list(table.join(toolset.getldflags(cfg), cfg.linkoptions)))\nend\nfunction make.libs(cfg, toolset)\nlocal flags = toolset.getlinks(cfg)\n_p('  LIBS +=%s', make.list(flags))\nend\nfunction make.linkCmd(cfg, toolset)\nif cfg.kind == premake.STATICLIB then\nif cfg.architecture == premake.UNIVERSAL then\n_p('  LINKCMD = libtool -o $(TARGET) $(OBJECTS)')\nelse\n_p('  LINKCMD = $(AR) -rcs $(TARGET) $(OBJECTS)')\nend\nelse\nlocal cc = iif(cfg.language == \"C\", \"CC\", \"CXX\")\n_p('  LINKCMD = $(%s) -o $(TARGET) $(OBJECTS) $(RESOURCES) $(ARCH) $(ALL_LDFLAGS) $(LIBS)', cc)\nend\nend\nfunction make.pch(cfg, toolset)\nif not cfg.pchheader or cfg.flags.NoPCH then\nreturn\nend"
	"\nlocal pch = cfg.pchheader\nfor _, incdir in ipairs(cfg.includedirs) do\nlocal testname = path.join(incdir, pch)\nif os.isfile(testname) then\npch = project.getrelative(cfg.project, testname)\nbreak\nend\nend\n_x('  PCH = %s', pch)\n_p('  GCH = $(OBJDIR)/$(notdir $(PCH)).gch')\nend\nfunction make.pchRules(prj)\n_p('ifneq (,$(PCH))')\n_p('$(GCH): $(PCH)')\n_p('\\t@echo $(notdir $<)')\nlocal cmd = iif(prj.language == \"C\", \"$(CC) -x c-header $(ALL_CFLAGS)\", \"$(CXX) -x c++-header $(ALL_CXXFLAGS)\")\n_p('\\t$(SILENT) %s -MMD -MP $(DEFINES) $(INCLUDES) -o \"$@\" -MF \"$(@:%%.gch=%%.d)\" -c \"$<\"', cmd)\n_p('endif')\n_p('')\nend\nfunction make.resFlags(cfg, toolset)\nlocal resflags = table.join(toolset.getdefines(cfg.resdefines), toolset.getincludedirs(cfg, cfg.resincludedirs), cfg.resoptions)\n_p('  ALL_RESFLAGS += $(RESFLAGS) $(DEFINES) $(INCLUDES)%s', make.list(resflags))\nend\n",

	/* actions/make/make_csharp.lua */
	"premake.make.cs = {}\nlocal make = premake.make\nlocal cs = premake.make.cs\nlocal project = premake.project\nlocal config = premake.config\nlocal fileconfig = premake.fileconfig\ncs.elements = {}\ncs.elements.makefile = {\n\"header\",\n\"phonyRules\",\n\"csConfigs\",\n\"csProjectConfig\",\n\"csSources\",\n\"csEmbedFiles\",\n\"csCopyFiles\",\n\"shellType\",\n\"csAllRules\",\n\"csTargetRules\",\n\"targetDirRules\",\n\"objDirRules\",\n\"csCleanRules\",\n\"preBuildRules\",\n\"preLinkRules\",\n\"csFileRules\",\n}\nfunction make.cs.generate(prj)\nlocal toolset = premake.tools.dotnet\npremake.callarray(make, cs.elements.makefile, prj, toolset)\nend\ncs.elements.configuration = {\n\"csTools\",\n\"target\",\n\"objdir\",\n\"csFlags\",\n\"csLinkCmd\",\n\"preBuildCmds\",\n\"preLinkCmds\",\n\"postBuildCmds\",\n\"settings\",\n}\nfunction make.csConfigs(prj, toolset)\nfor cfg in project.eachconfig(prj) do\n_x('ifeq ($(config),%s)', cfg.shortname)\npremake.callarray(make, cs.elements.configuration, cfg, toolset)\n_p('endif')"
	"\n_p('')\nend\nend\nfunction cs.getresourcefilename(cfg, fname)\nif path.getextension(fname) == \".resx\" then\n    local name = cfg.buildtarget.basename .. \".\"\n    local dir = path.getdirectory(fname)\n    if dir ~= \".\" then\nname = name .. path.translate(dir, \".\") .. \".\"\nend\nreturn \"$(OBJDIR)/\" .. premake.esc(name .. path.getbasename(fname)) .. \".resources\"\nelse\nreturn fname\nend\nend\nfunction cs.listsources(prj, selector)\nlocal tr = project.getsourcetree(prj)\npremake.tree.traverse(tr, {\nonleaf = function(node, depth)\nlocal value = selector(node)\nif value then\n_x('\\t%s \\\\', value)\nend\nend\n})\nend\nfunction make.csAllRules(prj, toolset)\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild $(EMBEDFILES) $(COPYFILES) prelink $(TARGET)')\n_p('')\nend\nfunction make.csCleanRules(prj, toolset)\nend\nfunction make.csCopyFiles(prj, toolset)\nend\nfunction make.csEmbedFiles(prj, toolset)\nlocal cfg = project.getfirstconfig(prj)\n_p('EMBEDFILES += \\\\')\ncs.listsources(prj, function(node)\nlocal fc"
	"fg = fileconfig.getconfig(node, cfg)\nlocal info = toolset.fileinfo(fcfg)\nif info.action == \"EmbeddedResource\" then\nreturn cs.getresourcefilename(cfg, node.relpath)\nend\nend)\n_p('')\nend\nfunction make.csFileRules(prj, toolset)\nend\nfunction make.csFlags(cfg, toolset)\n_p('  FLAGS =%s', make.list(toolset.getflags(cfg)))\nend\nfunction make.csLinkCmd(cfg, toolset)\nlocal deps = premake.esc(config.getlinks(cfg, \"dependencies\", \"fullpath\"))\n_p('  DEPENDS =%s', make.list(deps))\n_p('  REFERENCES = %s', table.implode(deps, \"/r:\", \"\", \" \"))\nend\nfunction make.csProjectConfig(prj, toolset)\nlocal cfg = project.getfirstconfig(prj)\nlocal kindflag = \"/t:\" .. toolset.getkind(cfg):lower()\nlocal libdirs = table.implode(premake.esc(cfg.libdirs), \"/lib:\", \"\", \" \")\n_p('FLAGS += %s', table.concat(table.join(kindflag, libdirs), \" \"))\nlocal refs = premake.esc(config.getlinks(cfg, \"system\", \"fullpath\"))\n_p('REFERENCES += %s', table.implode(refs, \"/r:\", \"\", \" \"))\n_p('')\nend\nfunction m"
	"ake.csSources(prj, toolset)\nlocal cfg = project.getfirstconfig(prj)\n_p('SOURCES += \\\\')\ncs.listsources(prj, function(node)\nlocal fcfg = fileconfig.getconfig(node, cfg)\nlocal info = toolset.fileinfo(fcfg)\nif info.action == \"Compile\" then\nreturn node.relpath\nend\nend)\n_p('')\nend\nfunction make.csTargetRules(prj, toolset)\n_p('$(TARGET): $(SOURCES) $(EMBEDFILES) $(DEPENDS)')\n_p('\\t$(SILENT) $(CSC) /nologo /out:$@ $(FLAGS) $(REFERENCES) $(SOURCES) $(patsubst %%,/resource:%%,$(EMBEDFILES))')\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\nend\nfunction make.csTools(cfg, toolset)\n_p('  CSC = %s', toolset.gettoolname(cfg, \"csc\"))\n_p('  RESGEN = %s', toolset.gettoolname(cfg, \"resgen\"))\nend\n",

	/* actions/vstudio/_vstudio.lua */
	"premake.vstudio = {}\nlocal vstudio = premake.vstudio\nlocal solution = premake.solution\nlocal project = premake.project\nlocal config = premake.config\nvstudio.vs200x_architectures =\n{\nx32     = \"x86\",\nx64     = \"x64\",\nxbox360 = \"Xbox 360\",\n}\nvstudio.vs2010_architectures =\n{\n}\nlocal function architecture(system, arch)\nlocal result\nif _ACTION >= \"vs2010\" then\nresult = vstudio.vs2010_architectures[arch] or vstudio.vs2010_architectures[system]\nend\nreturn result or vstudio.vs200x_architectures[arch] or vstudio.vs200x_architectures[system]\nend\nfunction vstudio.archFromConfig(cfg, win32)\nlocal iscpp = project.iscpp(cfg.project)\nlocal arch = architecture(cfg.system, cfg.architecture)\nif not arch then\narch = iif(iscpp, \"x86\", \"Any CPU\")\nend\nif win32 and iscpp and arch == \"x86\" then\narch = \"Win32\"\nend\nreturn arch\nend\nfunction vstudio.archFromPlatform(platform)\nlocal system = premake.api.checkvalue(platform, premake.fields.system)\nlocal arch = premake.api.checkvalue(platfor"
	"m, premake.fields.architecture)\nreturn architecture(system, arch)\nend\nfunction vstudio.isMakefile(cfg)\nreturn (cfg.kind == premake.MAKEFILE or cfg.kind == premake.NONE)\nend\nfunction vstudio.needsExplicitLink(cfg)\nlocal ex = cfg.flags.NoImplicitLink\nif not ex then\nlocal prjdeps = project.getdependencies(cfg.project)\nlocal cfgdeps = config.getlinks(cfg, \"dependencies\", \"object\")\nex = #prjdeps ~= #cfgdeps\nend\nreturn ex\nend\nfunction vstudio.projectConfig(cfg, arch)\nlocal platform = vstudio.projectPlatform(cfg)\nlocal architecture = arch or vstudio.archFromConfig(cfg, true)\nreturn platform .. \"|\" .. architecture\nend\nfunction vstudio.projectfile(prj)\nlocal extension\nif prj.language == \"C#\" then\nextension = \".csproj\"\nelse\nextension = iif(_ACTION > \"vs2008\", \".vcxproj\", \".vcproj\")\nend\nreturn project.getfilename(prj, extension)\nend\nfunction vstudio.projectPlatform(cfg)\nlocal platform = cfg.platform\nif platform then\nlocal pltarch = vstudio.archFromPlatform(cfg.platform) or "
	"platform\nlocal cfgarch = vstudio.archFromConfig(cfg)\nif pltarch == cfgarch then\nplatform = nil\nend\nend\nif platform then\nreturn cfg.buildcfg .. \" \" .. platform\nelse\nreturn cfg.buildcfg\nend\nend\nfunction vstudio.solutionPlatform(cfg)\nlocal platform = cfg.platform\nlocal platarch\nif platform then\nplatform = vstudio.archFromPlatform(platform) or platform\nif platform ~= \"x86\" then\nreturn platform\nend\nend\nlocal hascpp = false\nlocal hasnet = false\nlocal slnarch\nfor prj in solution.eachproject(cfg.solution) do\nif project.iscpp(prj) then\nhascpp = true\nelseif project.isdotnet(prj) then\nhasnet = true\nend\nlocal prjcfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)\nif prjcfg then\nlocal prjarch = vstudio.archFromConfig(prjcfg)\nif not slnarch then\nslnarch = prjarch\nelseif slnarch ~= prjarch then\nslnarch = \"Mixed Platforms\"\nend\nend\nend\nif platform then\nreturn iif(hasnet, \"x86\", \"Win32\")\nelseif slnarch then\nreturn iif(slnarch == \"x86\" and not hasnet, \"Win32\", slnarch"
	")\nelseif hasnet and hascpp then\nreturn \"Mixed Platforms\"\nelseif hasnet then\nreturn \"Any CPU\"\nelse\nreturn \"Win32\"\nend\nend\nfunction vstudio.solutionarch(cfg)\nlocal hascpp = false\nlocal hasdotnet = false\nlocal arch = cfg.platform\nfor prj in solution.eachproject(cfg.solution) do\nif project.iscpp(prj) then\nhascpp = true\nelseif project.isdotnet(prj) then\nhasdotnet = true\nend\nif hascpp and hasdotnet then\nreturn \"Mixed Platforms\"\nend\nif not arch then\nlocal prjcfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)\nif prjcfg then\nif prjcfg.architecture then\narch = vstudio.archFromConfig(prjcfg)\nend\nend\nend\nend\narch = arch or iif(hascpp, \"Win32\", \"Any CPU\")\nreturn arch\nend\nfunction vstudio.solutionconfig(cfg)\nlocal platform = cfg.platform\nif not platform then\nplatform = vstudio.solutionarch(cfg)\nend\nreturn string.format(\"%s|%s\", cfg.buildcfg, platform)\nend\nfunction vstudio.tool(prj)\nif (prj.language == \"C#\") then\nreturn \"FAE04EC0-301F-11D3-BF4B-00C04F79EFBC\""
	"\nelse\nreturn \"8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942\"\nend\nend\n",

	/* actions/vstudio/vs2005.lua */
	"premake.vstudio.vs2005 = {}\nlocal vs2005 = premake.vstudio.vs2005\nlocal vstudio = premake.vstudio\nfunction vs2005.generateSolution(sln)\nio.eol = \"\\r\\n\"\nio.esc = vs2005.esc\npremake.generate(sln, \".sln\", vstudio.sln2005.generate)\nend\nfunction vs2005.generateProject(prj)\nio.eol = \"\\r\\n\"\nio.esc = vs2005.esc\nif premake.project.isdotnet(prj) then\npremake.generate(prj, \".csproj\", vstudio.cs2005.generate)\npremake.generate(prj, \".csproj.user\", vstudio.cs2005.generate_user)\nelse\npremake.generate(prj, \".vcproj\", vstudio.vc200x.generate)\npremake.generate(prj, \".vcproj.user\", vstudio.vc200x.generate_user)\nend\nend\nfunction vs2005.esc(value)\nvalue = string.gsub(value, '&',  \"&amp;\")\nvalue = value:gsub('\"',  \"&quot;\")\nvalue = value:gsub(\"'\",  \"&apos;\")\nvalue = value:gsub('<',  \"&lt;\")\nvalue = value:gsub('>',  \"&gt;\")\nvalue = value:gsub('\\r', \"&#x0D;\")\nvalue = value:gsub('\\n', \"&#x0A;\")\nreturn value\nend\nnewaction {\ntrigger     = \"vs2005\",\nshortname   = \"Vis"
	"ual Studio 2005\",\ndescription = \"Generate Visual Studio 2005 project files\",\nos = \"windows\",\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\", \"Makefile\", \"None\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"msc\"   },\ndotnet = { \"msnet\" },\n},\nonsolution = vstudio.vs2005.generateSolution,\nonproject  = vstudio.vs2005.generateProject,\noncleansolution = vstudio.cleanSolution,\noncleanproject  = vstudio.cleanProject,\noncleantarget   = vstudio.cleanTarget,\nvstudio = {\ncsprojSchemaVersion = \"2.0\",\nproductVersion      = \"8.0.50727\",\nsolutionVersion     = \"9\",\n}\n}\n",

	/* actions/vstudio/vs2008.lua */
	"premake.vstudio.vs2008 = {}\nlocal vs2008 = premake.vstudio.vs2008\nlocal vstudio = premake.vstudio\nnewaction {\ntrigger     = \"vs2008\",\nshortname   = \"Visual Studio 2008\",\ndescription = \"Generate Visual Studio 2008 project files\",\nos = \"windows\",\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\", \"Makefile\", \"None\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"msc\"   },\ndotnet = { \"msnet\" },\n},\nonsolution = vstudio.vs2005.generateSolution,\nonproject  = vstudio.vs2005.generateProject,\noncleansolution = vstudio.cleanSolution,\noncleanproject  = vstudio.cleanProject,\noncleantarget   = vstudio.cleanTarget,\nvstudio = {\ncsprojSchemaVersion = \"2.0\",\nproductVersion      = \"9.0.30729\",\nsolutionVersion     = \"10\",\ntoolsVersion        = \"3.5\",\n}\n}\n",

	/* actions/vstudio/vs200x_vcproj.lua */
	"premake.vstudio.vc200x = {}\nlocal vstudio = premake.vstudio\nlocal vc200x = premake.vstudio.vc200x\nlocal context = premake.context\nlocal project = premake.project\nlocal config = premake.config\nlocal fileconfig = premake.fileconfig\nvc200x.elements = {}\nvc200x.elements.project = {\n\"xmlElement\",\n\"visualStudioProject\",\n\"platforms\",\n\"toolFiles\",\n\"configurations\",\n\"references\",\n\"files\",\n\"globals\",\n}\nfunction vc200x.generate(prj)\npremake.callarray(vc200x, vc200x.elements.project, prj)\n_p('</VisualStudioProject>')\nend\nvc200x.elements.projectAttributes = {\n\"projectType\",\n\"version\",\n\"projectName\",\n\"projectGUID\",\n\"rootNamespace\",\n\"keyword\",\n\"targetFrameworkVersion\"\n}\nfunction vc200x.visualStudioProject(prj)\n_p('<VisualStudioProject')\npremake.callarray(vc200x, vc200x.elements.projectAttributes, prj)\n_p(1,'>')\nend\nfunction vc200x.configurations(prj)\n_p(1,'<Configurations>')\nlocal prjcfgs = {}\nfor cfg in project.eachconfig(prj) do\nlocal cfgname = vstudio.p"
	"rojectConfig(cfg)\nprjcfgs[cfgname] = true\nend\nlocal architectures = vc200x.architectures(prj)\nfor cfg in project.eachconfig(prj) do\nlocal prjcfg = vstudio.projectConfig(cfg)\nfor _, arch in ipairs(architectures) do\nlocal tstcfg = vstudio.projectConfig(cfg, arch)\nif prjcfg == tstcfg then\nvc200x.configuration(cfg)\nvc200x.tools(cfg)\n_p(2,'</Configuration>')\nelseif not prjcfgs[tstcfg] then\nvc200x.emptyConfiguration(cfg, arch)\nend\nend\nend\n_p(1,'</Configurations>')\nend\nfunction vc200x.configuration(cfg)\n_p(2,'<Configuration')\n_x(3,'Name=\"%s\"', vstudio.projectConfig(cfg))\nlocal outdir = project.getrelative(cfg.project, cfg.buildtarget.directory)\n_x(3,'OutputDirectory=\"%s\"', path.translate(outdir))\nlocal objdir = project.getrelative(cfg.project, cfg.objdir)\n_x(3,'IntermediateDirectory=\"%s\"', path.translate(objdir))\nvc200x.configurationType(cfg)\nif (cfg.flags.MFC) then\n_p(3, 'UseOfMFC=\"%d\"', iif(cfg.flags.StaticRuntime, 1, 2))\nend\nvc200x.characterSet(cfg)\nif cfg.flags.Managed then"
	"\n_p(3,'ManagedExtensions=\"1\"')\nend\n_p(3,'>')\nend\nfunction vc200x.emptyConfiguration(cfg, arch)\n_p(2,'<Configuration')\n_x(3,'Name=\"%s|%s\"', vstudio.projectPlatform(cfg), arch)\n_p(3,'IntermediateDirectory=\"$(PlatformName)\\\\$(ConfigurationName)\"')\n_p(3,'ConfigurationType=\"1\"')\n_p(3,'>')\nlocal tools = vc200x.toolsForConfig(cfg, true)\nfor _, tool in ipairs(tools) do\nvc200x.tool(tool)\nend\n_p(2,'</Configuration>')\nend\nvc200x.elements.references = {\n\"assemblyReferences\",\n\"projectReferences\",\n}\nfunction vc200x.references(prj)\n_p(1,'<References>')\npremake.callarray(vc200x, vc200x.elements.references, prj)\n_p(1,'</References>')\nend\nvc200x.elements.globals = {\n}\nfunction vc200x.globals(prj)\n_p(1,'<Globals>')\npremake.callarray(vc200x, vc200x.elements.globals, prj)\n_p(1,'</Globals>')\nend\nfunction vc200x.toolsForConfig(cfg, isEmptyCfg)\nif vstudio.isMakefile(cfg) and not isEmptyCfg then\nreturn {\n\"VCNMakeTool\"\n}\nend\nif _ACTION == \"vs2002\" then\nreturn {\n\"VCCLCompilerTo"
	"ol\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCWebDeploymentTool\"\n}\nend\nif _ACTION == \"vs2003\" then\nreturn {\n\"VCCLCompilerTool\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebDeploymentTool\",\n\"VCManagedWrapperGeneratorTool\",\n\"VCAuxiliaryManagedWrapperGeneratorTool\"\n}\nend\nif cfg.system == premake.XBOX360 then\nreturn {\n\"VCPreBuildEventTool\",\n\"VCCustomBuildTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCMIDLTool\",\n\"VCCLCompilerTool\",\n\"VCManagedResourceCompilerTool\",\n\"VCResourceCompilerTool\",\n\"VCPreLinkEventTool\",\n\"VCLinkerTool\",\n\"VCALinkTool\",\n\"VCX360ImageTool\",\n\"VCBscMakeTool"
	"\",\n\"VCX360DeploymentTool\",\n\"VCPostBuildEventTool\",\n\"DebuggerTool\",\n}\nelse\nreturn {\n\"VCPreBuildEventTool\",\n\"VCCustomBuildTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCMIDLTool\",\n\"VCCLCompilerTool\",\n\"VCManagedResourceCompilerTool\",\n\"VCResourceCompilerTool\",\n\"VCPreLinkEventTool\",\n\"VCLinkerTool\",\n\"VCALinkTool\",\n\"VCManifestTool\",\n\"VCXDCMakeTool\",\n\"VCBscMakeTool\",\n\"VCFxCopTool\",\n\"VCAppVerifierTool\",\n\"VCPostBuildEventTool\"\n}\nend\nend\nvc200x.toolsets = {\nps3 = premake.tools.snc\n}\nfunction vc200x.toolset(cfg)\nreturn premake.tools[cfg.toolset] or vc200x.toolsets[cfg.system]\nend\nfunction vc200x.tools(cfg)\nfor _, tool in ipairs(vc200x.toolsForConfig(cfg)) do\nif vc200x.toolmap[tool] then\nvc200x.toolmap[tool](cfg)\nelse\nvc200x.tool(tool)\nend\nend\nend\nfunction vc200x.VCAppVerifierTool(cfg)\nif cfg.kind ~= premake.STATICLIB then\nvc200x.tool(\"VCAppVerifierTool\")\nend\nend\nfunction vc200x.VCCLCompilerTool(cfg)\n_p(3,'<Too"
	"l')\nvc200x.compilerToolName(cfg)\nlocal toolset = vc200x.toolset(cfg)\nif toolset then\nvc200x.VCCLExternalCompilerTool(cfg, toolset)\nelse\nvc200x.VCCLBuiltInCompilerTool(cfg)\nend\n_p(3,'/>')\nend\nvc200x.elements.builtInCompilerTool = {\n\"enableEnhancedInstructionSet\",\n\"floatingPointModel\",\n\"runtimeTypeInfo\",\n\"treatWChar_tAsBuiltInType\",\n}\nfunction vc200x.VCCLBuiltInCompilerTool(cfg)\nvc200x.VCCLCompilerTool_additionalOptions(cfg)\nvc200x.optimization(cfg, 4)\nif cfg.flags.NoFramePointer then\n_p(4,'OmitFramePointers=\"%s\"', vc200x.bool(true))\nend\nvc200x.additionalIncludeDirectories(cfg, cfg.includedirs)\nvc200x.wholeProgramOptimization(cfg)\nvc200x.preprocessorDefinitions(cfg, cfg.defines)\nvc200x.minimalRebuild(cfg)\nvc200x.basicRuntimeChecks(cfg)\nvc200x.bufferSecurityCheck(cfg)\nif config.isOptimizedBuild(cfg) then\n_p(4,'StringPooling=\"%s\"', vc200x.bool(true))\nend\nif cfg.flags.NoExceptions then\n_p(4,'ExceptionHandling=\"%s\"', iif(_ACTION < \"vs2005\", \"FALSE\", 0))\nelseif cfg.f"
	"lags.SEH and _ACTION > \"vs2003\" then\n_p(4,'ExceptionHandling=\"2\"')\nend\nvc200x.runtimeLibrary(cfg)\n_p(4,'EnableFunctionLevelLinking=\"%s\"', vc200x.bool(true))\npremake.callarray(vc200x, vc200x.elements.builtInCompilerTool, cfg)\nif not cfg.flags.NoPCH and cfg.pchheader then\n_p(4,'UsePrecompiledHeader=\"%s\"', iif(_ACTION < \"vs2005\", 3, 2))\n_x(4,'PrecompiledHeaderThrough=\"%s\"', cfg.pchheader)\nelse\n_p(4,'UsePrecompiledHeader=\"%s\"', iif(_ACTION > \"vs2003\" or cfg.flags.NoPCH, 0, 2))\nend\nvc200x.programDatabaseFileName(cfg)\nvc200x.warnings(cfg)\n_p(4,'DebugInformationFormat=\"%s\"', vc200x.symbols(cfg))\nif cfg.project.language == \"C\" then\n_p(4, 'CompileAs=\"1\"')\nend\nvc200x.forcedIncludeFiles(cfg)\nend\nfunction vc200x.VCCLExternalCompilerTool(cfg, toolset)\nvc200x.VCCLExternalCompilerTool_additionalOptions(cfg, toolset)\nvc200x.additionalIncludeDirectories(cfg, cfg.includedirs)\nvc200x.preprocessorDefinitions(cfg, cfg.defines)\nif not cfg.flags.NoPCH and cfg.pchheader then\n_p(4,'UsePre"
	"compiledHeader=\"%s\"', iif(_ACTION < \"vs2005\", 3, 2))\n_x(4,'PrecompiledHeaderThrough=\"%s\"', cfg.pchheader)\nelse\n_p(4,'UsePrecompiledHeader=\"%s\"', iif(_ACTION > \"vs2003\" or cfg.flags.NoPCH, 0, 2))\nend\nvc200x.programDatabaseFileName(cfg)\n_p(4,'DebugInformationFormat=\"0\"')\n_p(4,'CompileAs=\"0\"')\nvc200x.forcedIncludeFiles(cfg)\nend\nfunction vc200x.DebuggerTool(cfg)\n_p(3,'<DebuggerTool')\n_p(3,'/>')\nend\nfunction vc200x.VCLinkerTool(cfg)\n_p(3,'<Tool')\n_p(4,'Name=\"%s\"', vc200x.linkerTool(cfg))\nlocal toolset = vc200x.toolset(cfg)\nif toolset then\nvc200x.VCExternalLinkerTool(cfg, toolset)\nelse\nvc200x.VCBuiltInLinkerTool(cfg)\nend\n_p(3,'/>')\nend\nfunction vc200x.VCBuiltInLinkerTool(cfg)\nlocal explicitLink = vstudio.needsExplicitLink(cfg)\nif cfg.kind ~= premake.STATICLIB then\nif explicitLink then\n_p(4,'LinkLibraryDependencies=\"false\"')\nend\nif cfg.flags.NoImportLib then\n_p(4,'IgnoreImportLibrary=\"%s\"', vc200x.bool(true))\nend\nend\nif #cfg.linkoptions > 0 then\n_x(4,'Additional"
	"Options=\"%s\"', table.concat(cfg.linkoptions, \" \"))\nend\nif #cfg.links > 0 then\nlocal links = vc200x.links(cfg, explicitLink)\nif links ~= \"\" then\n_x(4,'AdditionalDependencies=\"%s\"', links)\nend\nend\n_x(4,'OutputFile=\"$(OutDir)\\\\%s\"', cfg.buildtarget.name)\nif cfg.kind ~= premake.STATICLIB then\n_p(4,'LinkIncremental=\"%s\"', iif(config.canLinkIncremental(cfg) , 2, 1))\nend\nvc200x.additionalLibraryDirectories(cfg)\nif cfg.kind ~= premake.STATICLIB then\nlocal deffile = config.findfile(cfg, \".def\")\nif deffile then\n_p(4,'ModuleDefinitionFile=\"%s\"', deffile)\nend\nif cfg.flags.NoManifest then\n_p(4,'GenerateManifest=\"%s\"', vc200x.bool(false))\nend\n_p(4,'GenerateDebugInformation=\"%s\"', vc200x.bool(vc200x.symbols(cfg) ~= 0))\nif vc200x.symbols(cfg) >= 3 then\n_x(4,'ProgramDataBaseFileName=\"$(OutDir)\\\\%s.pdb\"', cfg.buildtarget.basename)\nend\n_p(4,'SubSystem=\"%s\"', iif(cfg.kind == \"ConsoleApp\", 1, 2))\nif config.isOptimizedBuild(cfg) then\n_p(4,'OptimizeReferences=\"2\"')\n_p(4,'En"
	"ableCOMDATFolding=\"2\"')\nend\nif (cfg.kind == \"ConsoleApp\" or cfg.kind == \"WindowedApp\") and not cfg.flags.WinMain then\n_p(4,'EntryPointSymbol=\"mainCRTStartup\"')\nend\nif cfg.kind == \"SharedLib\" then\nlocal implibdir = cfg.linktarget.abspath\nif cfg.flags.NoImportLib then\nimplibdir = path.join(cfg.objdir, path.getname(implibdir))\nend\nimplibdir = project.getrelative(cfg.project, implibdir)\n_x(4,'ImportLibrary=\"%s\"', path.translate(implibdir))\nend\n_p(4,'TargetMachine=\"%d\"', iif(cfg.architecture == \"x64\", 17, 1))\nend\nend\nfunction vc200x.VCExternalLinkerTool(cfg, toolset)\nlocal explicitLink = vstudio.needsExplicitLink(cfg)\nlocal buildoptions = table.join(toolset.getldflags(cfg), cfg.linkoptions)\nif #buildoptions > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(buildoptions, \" \"))\nend\nif #cfg.links > 0 then\nlocal links = toolset.getlinks(cfg, not explicitLink)\nif #links > 0 then\n_x(4,'AdditionalDependencies=\"%s\"', table.concat(links, \" \"))\nend\nend\n_x(4,'OutputFile="
	"\"$(OutDir)\\\\%s\"', cfg.buildtarget.name)\nif cfg.kind ~= premake.STATICLIB then\n_p(4,'LinkIncremental=\"0\"')\nend\nvc200x.additionalLibraryDirectories(cfg)\nif cfg.kind ~= premake.STATICLIB then\n_p(4,'GenerateManifest=\"%s\"', vc200x.bool(false))\n_p(4,'ProgramDatabaseFile=\"\"')\n_p(4,'RandomizedBaseAddress=\"1\"')\n_p(4,'DataExecutionPrevention=\"0\"')\nend\nend\nfunction vc200x.VCManifestTool(cfg)\nif cfg.kind == premake.STATICLIB then\nreturn\nend\nlocal manifests = {}\nfor _, fname in ipairs(cfg.files) do\nif path.getextension(fname) == \".manifest\" then\ntable.insert(manifests, project.getrelative(cfg.project, fname))\nend\nend\n_p(3,'<Tool')\n_p(4,'Name=\"VCManifestTool\"')\nif #manifests > 0 then\n_x(4,'AdditionalManifestFiles=\"%s\"', table.concat(manifests, \";\"))\nend\n_p(3,'/>')\nend\nfunction vc200x.VCMIDLTool(cfg)\n_p(3,'<Tool')\n_p(4,'Name=\"VCMIDLTool\"')\nif cfg.architecture == \"x64\" then\n_p(4,'TargetEnvironment=\"3\"')\nend\n_p(3,'/>')\nend\nfunction vc200x.VCNMakeTool(cfg)\n_p(3,'"
	"<Tool')\n_p(4,'Name=\"VCNMakeTool\"')\nvc200x.nmakeCommandLine(cfg, cfg.buildcommands, \"Build\")\nvc200x.nmakeCommandLine(cfg, cfg.rebuildcommands, \"ReBuild\")\nvc200x.nmakeCommandLine(cfg, cfg.cleancommands, \"Clean\")\nvc200x.nmakeOutput(cfg)\n_p(4,'PreprocessorDefinitions=\"\"')\n_p(4,'IncludeSearchPath=\"\"')\n_p(4,'ForcedIncludes=\"\"')\n_p(4,'AssemblySearchPath=\"\"')\n_p(4,'ForcedUsingAssemblies=\"\"')\n_p(4,'CompileAsManaged=\"\"')\n_p(3,'/>')\nend\nfunction vc200x.VCResourceCompilerTool(cfg)\n_p(3,'<Tool')\n_p(4,'Name=\"VCResourceCompilerTool\"')\nif #cfg.resoptions > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(cfg.resoptions, \" \"))\nend\nvc200x.preprocessorDefinitions(cfg, table.join(cfg.defines, cfg.resdefines))\nvc200x.additionalIncludeDirectories(cfg, table.join(cfg.includedirs, cfg.resincludedirs))\n_p(3,'/>')\nend\nfunction vc200x.VCBuildEventTool(name, steps)\n_p(3,'<Tool')\n_p(4,'Name=\"%s\"', name)\nif #steps > 0 then\n_x(4,'CommandLine=\"%s\"', table.implode(steps, \"\", \"\", "
	"\"\\r\\n\"))\nend\n_p(3,'/>')\nend\nfunction vc200x.VCPreBuildEventTool(cfg)\nvc200x.VCBuildEventTool(\"VCPreBuildEventTool\", cfg.prebuildcommands)\nend\nfunction vc200x.VCPreLinkEventTool(cfg)\nvc200x.VCBuildEventTool(\"VCPreLinkEventTool\", cfg.prelinkcommands)\nend\nfunction vc200x.VCPostBuildEventTool(cfg)\nvc200x.VCBuildEventTool(\"VCPostBuildEventTool\", cfg.postbuildcommands)\nend\nfunction vc200x.VCX360DeploymentTool(cfg)\n_p(3,'<Tool')\n_p(4,'Name=\"VCX360DeploymentTool\"')\n_p(4,'DeploymentType=\"0\"')\nif #cfg.deploymentoptions > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(cfg.deploymentoptions, \" \"))\nend\n_p(3,'/>')\nend\nfunction vc200x.VCX360ImageTool(cfg)\n_p(3,'<Tool')\n_p(4,'Name=\"VCX360ImageTool\"')\nif #cfg.imageoptions > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(cfg.imageoptions, \" \"))\nend\nif cfg.imagepath ~= nil then\n_x(4,'OutputFileName=\"%s\"', path.translate(cfg.imagepath))\nend\n_p(3,'/>')\nend\nvc200x.toolmap = {\nDebuggerTool           = vc200x.Debugge"
	"rTool,\nVCAppVerifierTool      = vc200x.VCAppVerifierTool,\nVCCLCompilerTool       = vc200x.VCCLCompilerTool,\nVCLinkerTool           = vc200x.VCLinkerTool,\nVCManifestTool         = vc200x.VCManifestTool,\nVCMIDLTool             = vc200x.VCMIDLTool,\nVCNMakeTool            = vc200x.VCNMakeTool,\nVCPostBuildEventTool   = vc200x.VCPostBuildEventTool,\nVCPreBuildEventTool    = vc200x.VCPreBuildEventTool,\nVCPreLinkEventTool     = vc200x.VCPreLinkEventTool,\nVCResourceCompilerTool = vc200x.VCResourceCompilerTool,\nVCX360DeploymentTool   = vc200x.VCX360DeploymentTool,\nVCX360ImageTool        = vc200x.VCX360ImageTool\n}\nfunction vc200x.files(prj)\n_p(1,'<Files>')\nlocal tr = project.getsourcetree(prj, function(a,b)\nlocal istop = (a.parent.parent == nil)\nlocal aSortName = a.name\nlocal bSortName = b.name\nif a.relpath then\nif not b.relpath then\nreturn not istop\nend\naSortName = a.relpath:gsub(\"%.%.%/\", \"\")\nend\nif b.relpath then\nif not a.relpath then\nreturn istop\nend\nbSortName = b.relpath:gsub(\"%.%.%"
	"/\", \"\")\nend\nreturn aSortName < bSortName\nend)\npremake.tree.traverse(tr, {\nonbranchenter = function(node, depth)\n_p(depth, '<Filter')\n_p(depth, '\\tName=\"%s\"', node.name)\n_p(depth, '\\t>')\nend,\nonbranchexit = function(node, depth)\n_p(depth, '</Filter>')\nend,\nonleaf = function(node, depth)\n_p(depth, '<File')\n_p(depth, '\\tRelativePath=\"%s\"', path.translate(node.relpath))\n_p(depth, '\\t>')\nfor cfg in project.eachconfig(prj) do\nvc200x.fileConfiguration(cfg, node, depth + 1)\nend\n_p(depth, '</File>')\nend\n}, false, 2)\n_p(1,'</Files>')\nend\nfunction vc200x.fileConfiguration(cfg, node, depth)\nlocal filecfg = fileconfig.getconfig(node, cfg)\nlocal configAttribs = io.capture(function ()\nvc200x.fileConfiguration_extraAttributes(cfg, filecfg, depth + 1)\nend)\nlocal compilerAttribs = io.capture(function ()\nvc200x.fileConfiguration_compilerAttributes(cfg, filecfg, depth + 2)\nend)\nif #configAttribs > 0 or compilerAttribs:lines() > 1 then\n_p(depth,'<FileConfiguration')\n_p(depth + 1, 'Name"
	"=\"%s\"', vstudio.projectConfig(cfg))\nif #configAttribs > 0 then\n_p(\"%s\", configAttribs)\nend\n_p(depth + 1, '>')\n_p(depth + 1, '<Tool')\nif #compilerAttribs > 0 then\n_p(\"%s\", compilerAttribs)\nend\n_p(depth + 1, '/>')\n_p(depth, '</FileConfiguration>')\nend\nend\nfunction vc200x.fileConfiguration_extraAttributes(cfg, filecfg, depth)\nvc200x.excludedFromBuild(filecfg, depth)\nend\nfunction vc200x.fileConfiguration_compilerAttributes(cfg, filecfg, depth)\nvc200x.compilerToolName(cfg, filecfg, depth)\nif filecfg then\nvc200x.customBuildTool(filecfg, depth)\nvc200x.objectFile(filecfg, depth)\nvc200x.optimization(filecfg, depth)\nvc200x.usePrecompiledHeader(filecfg, depth)\nvc200x.VCCLCompilerTool_fileConfig_additionalOptions(filecfg, depth)\nvc200x.forcedIncludeFiles(filecfg, depth)\nvc200x.compileAs(filecfg, depth)\nend\nend\nfunction vc200x.architectures(prj)\narchitectures = {}\nfor cfg in project.eachconfig(prj) do\nlocal arch = vstudio.archFromConfig(cfg, true)\nif not table.contains(architectures, a"
	"rch) then\ntable.insert(architectures, arch)\nend\nend\nreturn architectures\nend\nfunction vc200x.bool(value)\nif (_ACTION < \"vs2005\") then\nreturn iif(value, \"TRUE\", \"FALSE\")\nelse\nreturn iif(value, \"true\", \"false\")\nend\nend\nfunction vc200x.links(cfg, explicit)\nlocal scope = iif(explicit, \"all\", \"system\")\nlocal links = config.getlinks(cfg, scope, \"fullpath\")\nfor i, link in ipairs(links) do\nif link:find(\" \", 1, true) then\nlink = '\"' .. link .. '\"'\nend\nlinks[i] = path.translate(link)\nend\nreturn table.concat(links, \" \")\nend\nfunction vc200x.linkerTool(cfg)\nif cfg.kind == premake.STATICLIB then\nreturn \"VCLibrarianTool\"\nelseif cfg.system == premake.XBOX360 then\nreturn \"VCX360LinkerTool\"\nelse\nreturn \"VCLinkerTool\"\nend\nend\nfunction vc200x.symbols(cfg)\nif not cfg.flags.Symbols then\nreturn 0\nelseif cfg.debugformat == \"c7\" then\nreturn 1\nelse\nif cfg.flags.NoEditAndContinue or\nconfig.isOptimizedBuild(cfg) or\n    cfg.flags.Managed or\n    cfg.system == \"x64\" o"
	"r\ncfg.platform == \"x64\"  -- TODO: remove this when the _ng stuff goes live\nthen\nreturn 3\nelse\nreturn 4\nend\nend\nend\nfunction vc200x.additionalIncludeDirectories(cfg, includedirs)\nif #includedirs > 0 then\nlocal dirs = project.getrelative(cfg.project, includedirs)\n_x(4,'AdditionalIncludeDirectories=\"%s\"', path.translate(table.concat(dirs, \";\")))\nend\nend\nfunction vc200x.additionalLibraryDirectories(cfg)\nif #cfg.libdirs > 0 then\nlocal dirs = table.concat(project.getrelative(cfg.project, cfg.libdirs), \";\")\n_x(4,'AdditionalLibraryDirectories=\"%s\"', path.translate(dirs))\nend\nend\nfunction vc200x.VCCLCompilerTool_additionalOptions(cfg)\nlocal opts = cfg.buildoptions\nif cfg.flags.MultiProcessorCompile then\ntable.insert(opts, \"/MP\")\nend\nif #opts > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(opts, \" \"))\nend\nend\nfunction vc200x.VCCLCompilerTool_fileConfig_additionalOptions(filecfg, depth)\nlocal opts = filecfg.buildoptions\nif #opts > 0 then\n_x(depth, 'AdditionalOptions="
	"\"%s\"', table.concat(opts, \" \"))\nend\nend\nfunction vc200x.VCCLExternalCompilerTool_additionalOptions(cfg, toolset)\nlocal buildoptions = table.join(toolset.getcflags(cfg), toolset.getcxxflags(cfg), cfg.buildoptions)\nif not cfg.flags.NoPCH and cfg.pchheader then\ntable.insert(buildoptions, '--use_pch=\"$(IntDir)/$(TargetName).pch\"')\nend\nif #buildoptions > 0 then\n_x(4,'AdditionalOptions=\"%s\"', table.concat(buildoptions, \" \"))\nend\nend\nfunction vc200x.assemblyReferences(prj)\nlocal cfg = project.getfirstconfig(prj)\nlocal refs = config.getlinks(cfg, \"system\", \"fullpath\", \"managed\")\ntable.foreachi(refs, function(value)\n_p(2,'<AssemblyReference')\n_x(3,'RelativePath=\"%s\"', path.translate(value))\n_p(2,'/>')\nend)\nend\nfunction vc200x.basicRuntimeChecks(cfg)\nif not config.isOptimizedBuild(cfg)\nand not cfg.flags.Managed\nand not cfg.flags.NoRuntimeChecks\nthen\n_p(4,'BasicRuntimeChecks=\"3\"')\nend\nend\nfunction vc200x.bufferSecurityCheck(cfg)\nif cfg.flags.NoBufferSecurityCheck then\n_p"
	"(4,'BufferSecurityCheck=\"false\"')\nend\nend\nfunction vc200x.characterSet(cfg)\nif not vstudio.isMakefile(cfg) then\n_p(3,'CharacterSet=\"%s\"', iif(cfg.flags.Unicode, 1, 2))\nend\nend\nfunction vc200x.compileAs(filecfg, depth)\nif path.iscfile(filecfg.name) ~= project.isc(filecfg.project) then\nif path.iscppfile(filecfg.name) then\nlocal value = iif(filecfg.project.language == premake.CPP, 1, 2)\n_p(depth, 'CompileAs=\"%s\"', value)\nend\nend\nend\nfunction vc200x.compilerToolName(cfg, filecfg, depth)\nlocal name\nif fileconfig.hasCustomBuildRule(filecfg) then\nname = \"VCCustomBuildTool\"\nelse\nname = iif(cfg.system == premake.XBOX360, \"VCCLX360CompilerTool\", \"VCCLCompilerTool\")\nend\n_p(depth or 4,'Name=\"%s\"', name)\nend\nfunction vc200x.configurationType(cfg)\nlocal cfgtypes = {\nMakefile = 0,\nNone = 0,\nSharedLib = 2,\nStaticLib = 4,\n}\n_p(3,'ConfigurationType=\"%s\"', cfgtypes[cfg.kind] or 1)\nend\nfunction vc200x.customBuildTool(filecfg, depth)\nif fileconfig.hasCustomBuildRule(filecfg) then"
	"\n_x(depth, 'CommandLine=\"%s\"', table.concat(filecfg.buildcommands,'\\r\\n'))\nlocal outputs = project.getrelative(filecfg.project, filecfg.buildoutputs)\n_x(depth, 'Outputs=\"%s\"', table.concat(outputs, ' '))\nend\nend\nfunction vc200x.enableEnhancedInstructionSet(cfg)\nlocal map = { SSE = \"1\", SSE2 = \"2\" }\nlocal value = map[cfg.vectorextensions]\nif value and cfg.system ~= \"Xbox360\" and cfg.architecture ~= \"x64\" then\n_p(4,'EnableEnhancedInstructionSet=\"%d\"', value)\nend\nend\nfunction vc200x.excludedFromBuild(filecfg, depth)\nif not filecfg or filecfg.flags.ExcludeFromBuild then\n_p(depth, 'ExcludedFromBuild=\"true\"')\nend\nend\nfunction vc200x.floatingPointModel(cfg)\nlocal map = { Strict = \"1\", Fast = \"2\" }\nlocal value = map[cfg.floatingpoint]\nif value then\n_p(4,'FloatingPointModel=\"%d\"', value)\nend\nend\nfunction vc200x.forcedIncludeFiles(cfg, depth)\nif #cfg.forceincludes > 0 then\nlocal includes = path.translate(project.getrelative(cfg.project, cfg.forceincludes))\n_x(depth or "
	"4,'ForcedIncludeFiles=\"%s\"', table.concat(includes, ';'))\nend\nif #cfg.forceusings > 0 then\nlocal usings = path.translate(project.getrelative(cfg.project, cfg.forceusings))\n_x(depth or 4,'ForcedUsingFiles=\"%s\"', table.concat(usings, ';'))\nend\nend\nfunction vc200x.keyword(prj)\nlocal windows, managed, makefile\nfor cfg in project.eachconfig(prj) do\nif cfg.system == premake.WINDOWS then windows = true end\nif cfg.flags.Managed then managed = true end\nif vstudio.isMakefile(cfg) then makefile = true end\nend\nif windows then\nlocal keyword = \"Win32Proj\"\nif managed then\nkeyword = \"ManagedCProj\"\nend\nif makefile then\nkeyword = \"MakeFileProj\"\nend\n_p(1,'Keyword=\"%s\"', keyword)\nend\nend\nfunction vc200x.minimalRebuild(cfg)\nif config.isDebugBuild(cfg) and\n   cfg.debugformat ~= \"c7\" and\n   not cfg.flags.NoMinimalRebuild and\n   not cfg.flags.Managed and\n   not cfg.flags.MultiProcessorCompile\nthen\n_p(4,'MinimalRebuild=\"%s\"', vc200x.bool(true))\nend\nend\nfunction vc200x.nmakeCommandLine"
	"(cfg, commands, phase)\ncommands = table.concat(commands, \"\\r\\n\")\n_p(4,'%sCommandLine=\"%s\"', phase, premake.esc(commands))\nend\nfunction vc200x.nmakeOutput(cfg)\n_p(4,'Output=\"$(OutDir)%s\"', cfg.buildtarget.name)\nend\nfunction vc200x.objectFile(filecfg, depth)\nif path.iscppfile(filecfg.name) then\nif filecfg.objname ~= path.getbasename(filecfg.abspath) then\n_x(depth, 'ObjectFile=\"$(IntDir)\\\\%s.obj\"', filecfg.objname)\nend\nend\nend\nfunction vc200x.optimization(cfg, depth)\nlocal map = { Off=0, On=3, Debug=0, Full=3, Size=1, Speed=2 }\nlocal value = map[cfg.optimize]\nif value or not cfg.abspath then\n_p(depth,'Optimization=\"%s\"', value or 0)\nend\nend\nfunction vc200x.platforms(prj)\n_p(1,'<Platforms>')\ntable.foreachi(vc200x.architectures(prj), function(arch)\n_p(2,'<Platform')\n_p(3,'Name=\"%s\"', arch)\n_p(2,'/>')\nend)\n_p(1,'</Platforms>')\nend\nfunction vc200x.preprocessorDefinitions(cfg, defines)\nif #defines > 0 then\n_x(4,'PreprocessorDefinitions=\"%s\"', table.concat(defines, \";"
	"\"))\nend\nend\nfunction vc200x.programDatabaseFileName(cfg)\nlocal target = cfg.buildtarget\n_x(4,'ProgramDataBaseFileName=\"$(OutDir)\\\\%s%s.pdb\"', target.prefix, target.basename)\nend\nfunction vc200x.projectGUID(prj)\n_p(1,'ProjectGUID=\"{%s}\"', prj.uuid)\nend\nfunction vc200x.projectName(prj)\n_x(1,'Name=\"%s\"', prj.name)\nend\nfunction vc200x.projectReferences(prj)\nlocal deps = project.getdependencies(prj)\nif #deps > 0 then\nfor _, dep in ipairs(deps) do\nlocal relpath = path.getrelative(prj.solution.location, vstudio.projectfile(dep))\nif not relpath:startswith(\".\") then\nrelpath = \"./\" .. relpath\nend\n_p(2,'<ProjectReference')\n_p(3,'ReferencedProjectIdentifier=\"{%s}\"', dep.uuid)\n_p(3,'RelativePathToProject=\"%s\"', path.translate(relpath))\n_p(2,'/>')\nend\nend\nend\nfunction vc200x.projectType(prj)\n_p(1,'ProjectType=\"Visual C++\"')\nend\nfunction vc200x.rootNamespace(prj)\nlocal hasWindows = project.hasConfig(prj, function(cfg)\nreturn cfg.system == premake.WINDOWS\nend)\nif hasWindow"
	"s and _ACTION > \"vs2003\" then\n_x(1,'RootNamespace=\"%s\"', prj.name)\nend\nend\nfunction vc200x.runtimeLibrary(cfg)\nlocal runtimes = {\nStaticRelease = 0,\nStaticDebug = 1,\nSharedRelease = 2,\nSharedDebug = 3,\n}\n_p(4,'RuntimeLibrary=\"%s\"', runtimes[config.getruntime(cfg)])\nend\nfunction vc200x.runtimeTypeInfo(cfg)\nif cfg.flags.NoRTTI and not cfg.flags.Managed then\n_p(4,'RuntimeTypeInfo=\"false\"')\nend\nend\nfunction vc200x.targetFrameworkVersion(prj)\nlocal windows, makefile\nfor cfg in project.eachconfig(prj) do\nif cfg.system == premake.WINDOWS then windows = true end\nif vstudio.isMakefile(cfg) then makefile = true end\nend\nlocal version = 0\nif makefile or not windows then\nversion = 196613\nend\n_p(1,'TargetFrameworkVersion=\"%d\"', version)\nend\nfunction vc200x.tool(name)\n_p(3,'<Tool')\n_p(4,'Name=\"%s\"', name)\n_p(3,'/>')\nend\nfunction vc200x.toolFiles(prj)\nif _ACTION > \"vs2003\" then\n_p(1,'<ToolFiles>')\n_p(1,'</ToolFiles>')\nend\nend\nfunction vc200x.treatWChar_tAsBuiltInType(cfg)"
	"\nlocal map = { On = \"true\", Off = \"false\" }\nlocal value = map[cfg.nativewchar]\nif value then\n_p(4,'TreatWChar_tAsBuiltInType=\"%s\"', value)\nend\nend\nfunction vc200x.usePrecompiledHeader(filecfg, depth)\nlocal cfg = filecfg.config\nif cfg.pchsource == filecfg.abspath and\n   not cfg.flags.NoPCH and\n   cfg.system ~= premake.PS3\nthen\n_p(depth, 'UsePrecompiledHeader=\"1\"')\nend\nend\nfunction vc200x.version(prj)\nlocal map = {\nvs2002 = '7.0',\nvs2003 = '7.1',\nvs2005 = '8.0',\nvs2008 = '9.0'\n}\n_p(1,'Version=\"%s0\"', map[_ACTION])\nend\nfunction vc200x.warnings(cfg)\nif cfg.warnings == \"Off\" then\n_p(4,'WarningLevel=\"0\"')\nelse\n_p(4,'WarningLevel=\"%d\"', iif(cfg.warnings == \"Extra\", 4, 3))\nif cfg.flags.FatalWarnings then\n_p(4,'WarnAsError=\"%s\"', vc200x.bool(true))\nend\nif _ACTION < \"vs2008\" and not cfg.flags.Managed then\n_p(4,'Detect64BitPortabilityProblems=\"%s\"', vc200x.bool(not cfg.flags.No64BitChecks))\nend\nend\nend\nfunction vc200x.wholeProgramOptimization(cfg)\nif cfg.flag"
	"s.LinkTimeOptimization then\n_x(4,'WholeProgramOptimization=\"true\"')\nend\nend\nfunction vc200x.xmlElement()\n_p('<?xml version=\"1.0\" encoding=\"Windows-1252\"?>')\nend\n",

	/* actions/vstudio/vs200x_vcproj_user.lua */
	"local vstudio = premake.vstudio\nlocal vc200x = premake.vstudio.vc200x\nlocal project = premake.project\nfunction vc200x.generate_user(prj)\nvc200x.xmlElement()\n_p('<VisualStudioUserFile')\n_p(1,'ProjectType=\"Visual C++\"')\nvc200x.version()\n_p(1,'ShowAllFiles=\"false\"')\n_p(1,'>')\n_p(1,'<Configurations>')\nfor cfg in project.eachconfig(prj) do\nvc200x.userconfiguration(cfg)\nvc200x.debugdir(cfg)\n_p(2,'</Configuration>')\nend\n_p(1,'</Configurations>')\n_p('</VisualStudioUserFile>')\nend\nfunction vc200x.userconfiguration(cfg)\n_p(2,'<Configuration')\n_x(3,'Name=\"%s\"', vstudio.projectConfig(cfg))\n_p(3,'>')\nend\nfunction vc200x.debugdir(cfg)\n_p(3,'<DebugSettings')\nif cfg.debugcommand then\nlocal command = project.getrelative(cfg.project, cfg.debugcommand)\n_x(4,'Command=\"%s\"', path.translate(command))\nend\nif cfg.debugdir then\nlocal debugdir = project.getrelative(cfg.project, cfg.debugdir)\n_x(4,'WorkingDirectory=\"%s\"', path.translate(debugdir))\nend\nif #cfg.debugargs > 0 then\n_x(4,'CommandA"
	"rguments=\"%s\"', table.concat(cfg.debugargs, \" \"))\nend\nif #cfg.debugenvs > 0 then\n_p(4,'Environment=\"%s\"', table.concat(premake.esc(cfg.debugenvs), \"&#x0A;\"))\nif cfg.flags.DebugEnvsDontMerge then\n_p(4,'EnvironmentMerge=\"false\"')\nend\nend\n_p(3,'/>')\nend\n",

	/* actions/vstudio/vs2005_solution.lua */
	"premake.vstudio.sln2005 = {}\nlocal vstudio = premake.vstudio\nlocal sln2005 = premake.vstudio.sln2005\nlocal solution = premake.solution\nlocal project = premake.project\nlocal tree = premake.tree\nfunction sln2005.generate(sln)\n_p('\\239\\187\\191')\nsln2005.reorderProjects(sln)\nsln2005.header()\nsln2005.projects(sln)\n_p('Global')\nsln2005.configurationPlatforms(sln)\nsln2005.properties(sln)\nsln2005.NestedProjects(sln)\n_p('EndGlobal')\nend\nfunction sln2005.header()\nlocal action = premake.action.current()\n_p('Microsoft Visual Studio Solution File, Format Version %d.00', action.vstudio.solutionVersion)\n_p('# Visual Studio %s', _ACTION:sub(3))\nend\nfunction sln2005.reorderProjects(sln)\nif sln.startproject then\nlocal np\nlocal tr = solution.grouptree(sln)\ntree.traverse(tr, {\nonleaf = function(n)\nif n.project.name == sln.startproject then\nnp = n\nend\nend\n})\nwhile np and np.parent do\nlocal p = np.parent\nlocal i = table.indexof(p.children, np)\ntable.remove(p.children, i)\ntable.insert(p.childr"
	"en, 1, np)\nnp = p\nend\nend\nend\nfunction sln2005.projects(sln)\nlocal tr = solution.grouptree(sln)\ntree.traverse(tr, {\nonleaf = function(n)\nlocal prj = n.project\nlocal prjpath = vstudio.projectfile(prj)\nprjpath = path.translate(path.getrelative(prj.solution.location, prjpath))\n_x('Project(\"{%s}\") = \"%s\", \"%s\", \"{%s}\"', vstudio.tool(prj), prj.name, prjpath, prj.uuid)\nif _ACTION < \"vs2012\" then\nsln2005.projectdependencies(prj)\nend\n_p('EndProject')\nend,\nonbranch = function(n)\n_x('Project(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"%s\", \"%s\", \"{%s}\"', n.name, n.name, n.uuid)\n_p('EndProject')\nend,\n})\nend\nfunction sln2005.projectdependencies(prj)\nlocal deps = project.getdependencies(prj)\nif #deps > 0 then\n_p(1,'ProjectSection(ProjectDependencies) = postProject')\nfor _, dep in ipairs(deps) do\n_p(2,'{%s} = {%s}', dep.uuid, dep.uuid)\nend\n_p(1,'EndProjectSection')\nend\nend\nfunction sln2005.configurationPlatforms(sln)\nlocal descriptors = {}\nlocal sorted = {}\nfor cfg in "
	"solution.eachconfig(sln) do\nlocal platform = vstudio.solutionPlatform(cfg)\ndescriptors[cfg] = string.format(\"%s|%s\", cfg.buildcfg, platform)\ntable.insert(sorted, cfg)\nend\ntable.sort(sorted, function(cfg0, cfg1)\nreturn descriptors[cfg0]:lower() < descriptors[cfg1]:lower()\nend)\n_p(1,'GlobalSection(SolutionConfigurationPlatforms) = preSolution')\ntable.foreachi(sorted, function (cfg)\n_p(2,'%s = %s', descriptors[cfg], descriptors[cfg])\nend)\n_p(1,\"EndGlobalSection\")\n_p(1,\"GlobalSection(ProjectConfigurationPlatforms) = postSolution\")\nlocal tr = solution.grouptree(sln)\ntree.traverse(tr, {\nonleaf = function(n)\nlocal prj = n.project\ntable.foreachi(sorted, function (cfg)\nlocal platform, architecture\nlocal prjCfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)\nlocal excluded = (prjCfg == nil)\nif excluded then\nprjCfg = project.findClosestMatch(prj, cfg.buildcfg, cfg.platform)\nend\nlocal descriptor = descriptors[cfg]\nlocal platform = vstudio.projectPlatform(prjCfg)\nlocal architecture = v"
	"studio.archFromConfig(prjCfg, true)\n_p(2,'{%s}.%s.ActiveCfg = %s|%s', prj.uuid, descriptor, platform, architecture)\nif not excluded and prjCfg.kind ~= premake.NONE then\n_p(2,'{%s}.%s.Build.0 = %s|%s', prj.uuid, descriptor, platform, architecture)\nend\nend)\nend\n})\n_p(1,\"EndGlobalSection\")\nend\nfunction sln2005.properties(sln)\n_p('\\tGlobalSection(SolutionProperties) = preSolution')\n_p('\\t\\tHideSolutionNode = FALSE')\n_p('\\tEndGlobalSection')\nend\nfunction sln2005.NestedProjects(sln)\nlocal tr = solution.grouptree(sln)\nif tree.hasbranches(tr) then\n_p(1,'GlobalSection(NestedProjects) = preSolution')\ntree.traverse(tr, {\nonnode = function(n)\nif n.parent.uuid then\n_p(2,'{%s} = {%s}', (n.project or n).uuid, n.parent.uuid)\nend\nend\n})\n_p(1,'EndGlobalSection')\nend\nend\n",

	/* actions/vstudio/vs2005_csproj.lua */
	"premake.vstudio.cs2005 = {}\nlocal vstudio = premake.vstudio\nlocal cs2005  = premake.vstudio.cs2005\nlocal project = premake.project\nlocal config = premake.config\nlocal fileconfig = premake.fileconfig\nlocal dotnet = premake.tools.dotnet\ncs2005.elements = {}\ncs2005.elements.project = {\n\"projectElement\",\n\"projectProperties\",\n\"configurations\",\n\"applicationIcon\",\n\"assemblyReferences\",\n}\nfunction cs2005.generate(prj)\nio.indent = \"  \"\nio.utf8()\npremake.callarray(cs2005, cs2005.elements.project, prj)\n_p(1,'<ItemGroup>')\ncs2005.files(prj)\n_p(1,'</ItemGroup>')\ncs2005.projectReferences(prj)\ncs2005.targets(prj)\ncs2005.buildEvents(prj)\nio.printf('</Project>')\nend\nfunction cs2005.projectElement(prj)\nif _ACTION > \"vs2008\" then\n_p('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\nend\nlocal ver = ''\nlocal action = premake.action.current()\nif action.vstudio.toolsVersion then\nver = string.format(' ToolsVersion=\"%s\"', action.vstudio.toolsVersion)\nend\n_p('<Project%s DefaultTargets=\"B"
	"uild\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">', ver)\nend\nfunction cs2005.projectProperties(prj)\n_p(1,'<PropertyGroup>')\nlocal cfg = project.getfirstconfig(prj)\n_p(2,'<Configuration Condition=\" \\'$(Configuration)\\' == \\'\\' \">%s</Configuration>', premake.esc(cfg.buildcfg))\n_p(2,'<Platform Condition=\" \\'$(Platform)\\' == \\'\\' \">%s</Platform>', cs2005.arch(prj))\ncs2005.productVersion(prj)\ncs2005.schemaVersion(prj)\n_p(2,'<ProjectGuid>{%s}</ProjectGuid>', prj.uuid)\n_p(2,'<OutputType>%s</OutputType>', dotnet.getkind(cfg))\n_p(2,'<AppDesignerFolder>Properties</AppDesignerFolder>')\nlocal target = cfg.buildtarget\n_p(2,'<RootNamespace>%s</RootNamespace>', prj.namespace or target.basename)\n_p(2,'<AssemblyName>%s</AssemblyName>', target.basename)\ncs2005.targetFrameworkVersion(prj)\ncs2005.targetFrameworkProfile(prj)\ncs2005.fileAlignment(prj)\n_p(1,'</PropertyGroup>')\nend\ncs2005.elements.configuration = {\n\"propertyGroup\",\n\"debugProps\",\n\"outputProps\",\n\"compilerPr"
	"ops\",\n}\nfunction cs2005.configurations(prj)\nfor cfg in project.eachconfig(prj) do\nprint(cfg.shortname)\ncs2005.configuration(cfg)\nend\nend\nfunction cs2005.configuration(cfg)\npremake.callarray(cs2005, cs2005.elements.configuration, cfg)\n_p(1,'</PropertyGroup>')\nend\nfunction cs2005.files(prj)\nlocal cfg = project.getfirstconfig(prj)\nlocal tr = project.getsourcetree(prj)\npremake.tree.traverse(tr, {\nonleaf = function(node, depth)\nlocal filecfg = fileconfig.getconfig(node, cfg)\nlocal fname = path.translate(node.relpath)\nlocal link, count = node.relpath:gsub(\"%.%.%/\", \"\")\nlocal external = (count > 0)\nif external and node.vpath ~= node.relpath then\nlink = node.vpath\nend\nlocal info = dotnet.fileinfo(filecfg)\nif not info.subtype and not info.dependency and not external then\n_p(2,'<%s Include=\"%s\" />', info.action, fname)\nelse\n_p(2,'<%s Include=\"%s\">', info.action, fname)\nif external then\n_p(3,'<Link>%s</Link>', path.translate(link))\nend\nif info.subtype == \"AutoGenerated\" then\n_p"
	"(3,\"<AutoGen>True</AutoGen>\")\nelseif info.subtype == \"Designer\" then\n_p(3,'<SubType>Designer</SubType>')\n_p(3,'<Generator>ResXFileCodeGenerator</Generator>')\n_x(3,'<LastGenOutput>%s.Designer.cs</LastGenOutput>', path.getbasename(node.name))\nelseif info.subtype == \"PreserveNewest\" then\n_p(3,'<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>')\nelseif info.subtype then\n_p(3,'<SubType>%s</SubType>', info.subtype)\nend\nif info.dependency then\nlocal dependency = path.translate(project.getrelative(prj, info.dependency))\n_x(3,'<DependentUpon>%s</DependentUpon>', dependency)\nend\n_p(2,'</%s>', info.action)\nend\nend\n}, false)\nend\nfunction cs2005.buildEvents(prj)\nlocal function output(name, steps)\nif #steps > 0 then\n_x(2,'<%sBuildEvent>%s</%sBuildEvent>', name, table.implode(steps, \"\", \"\", \"\\r\\n\"), name)\nend\nend\nif #prj.prebuildcommands > 0 or #prj.postbuildcommands > 0 then\n_p(1,'<PropertyGroup>')\noutput(\"Pre\", prj.prebuildcommands)\noutput(\"Post\", prj.postbuildcomma"
	"nds)\n_p(1,'</PropertyGroup>')\nend\nend\nfunction cs2005.compilerProps(cfg)\n_x(2,'<DefineConstants>%s</DefineConstants>', table.concat(cfg.defines, \";\"))\n_p(2,'<ErrorReport>prompt</ErrorReport>')\n_p(2,'<WarningLevel>4</WarningLevel>')\nif cfg.flags.Unsafe then\n_p(2,'<AllowUnsafeBlocks>true</AllowUnsafeBlocks>')\nend\nif cfg.flags.FatalWarnings then\n_p(2,'<TreatWarningsAsErrors>true</TreatWarningsAsErrors>')\nend\nend\nfunction cs2005.debugProps(cfg)\nif cfg.flags.Symbols then\n_p(2,'<DebugSymbols>true</DebugSymbols>')\n_p(2,'<DebugType>full</DebugType>')\nelse\n_p(2,'<DebugType>pdbonly</DebugType>')\nend\n_p(2,'<Optimize>%s</Optimize>', iif(config.isOptimizedBuild(cfg), \"true\", \"false\"))\nend\nfunction cs2005.outputProps(cfg)\nlocal outdir = project.getrelative(cfg.project, cfg.buildtarget.directory)\n_x(2,'<OutputPath>%s\\\\</OutputPath>', path.translate(outdir))\nlocal objdir = path.translate(project.getrelative(cfg.project, cfg.objdir))\nif _ACTION > \"vs2008\" then\n_x(2,'<BaseIntermediateOutpu"
	"tPath>%s\\\\</BaseIntermediateOutputPath>', objdir)\n_p(2,'<IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>')\nelse\n_x(2,'<IntermediateOutputPath>%s\\\\</IntermediateOutputPath>', objdir)\nend\nend\nfunction cs2005.assemblyReferences(prj)\n_p(1,'<ItemGroup>')\nlocal cfg = project.getfirstconfig(prj)\nconfig.getlinks(cfg, \"system\", function(original, decorated)\nif decorated:find(\"/\", nil, true) then\n_x(2,'<Reference Include=\"%s\">', path.getbasename(decorated))\n_x(3,'<HintPath>%s</HintPath>', path.translate(decorated))\nif not config.isCopyLocal(prj, original, true) then\n_p(3,\"<Private>False</Private>\")\nend\n_p(2,'</Reference>')\nelse\n_x(2,'<Reference Include=\"%s\" />', path.getbasename(decorated))\nend\nend)\n_p(1,'</ItemGroup>')\nend\nfunction cs2005.projectReferences(prj)\n_p(1,'<ItemGroup>')\nlocal deps = project.getdependencies(prj)\nif #deps > 0 then\nfor _, dep in ipairs(deps) do\nlocal relpath = project.getrelative(prj, vstudio.projectfile(dep))\n_x(2,'<Proje"
	"ctReference Include=\"%s\">', path.translate(relpath))\n_p(3,'<Project>{%s}</Project>', dep.uuid)\n_x(3,'<Name>%s</Name>', dep.name)\nif not config.isCopyLocal(prj, dep.name, true) then\n_p(3,\"<Private>False</Private>\")\nend\n_p(2,'</ProjectReference>')\nend\nend\n_p(1,'</ItemGroup>')\nend\nfunction cs2005.arch(cfg)\nlocal arch = vstudio.archFromConfig(cfg)\nif arch == \"Any CPU\" then\narch = \"AnyCPU\"\nend\nreturn arch\nend\nfunction cs2005.propertyGroup(cfg)\nlocal arch = cs2005.arch(cfg)\n_x(1,'<PropertyGroup Condition=\" \\'$(Configuration)|$(Platform)\\' == \\'%s|%s\\' \">', cfg.buildcfg, arch)\nif arch ~= \"AnyCPU\" or _ACTION > \"vs2008\" then\n_x(2,'<PlatformTarget>%s</PlatformTarget>', arch)\nend\nend\nfunction cs2005.applicationIcon(prj)\nif prj.icon then\nlocal icon = path.translate(project.getrelative(prj, prj.icon))\n_p(1,'<PropertyGroup>')\n_x(2,'<ApplicationIcon>%s</ApplicationIcon>', icon)\n_p(1,'</PropertyGroup>')\nend\nend\nfunction cs2005.fileAlignment(prj)\nif _ACTION >= \"vs2010\" then"
	"\n_p(2,'<FileAlignment>512</FileAlignment>')\nend\nend\nfunction cs2005.productVersion(prj)\nlocal action = premake.action.current()\nif action.vstudio.productVersion then\n_p(2,'<ProductVersion>%s</ProductVersion>', action.vstudio.productVersion)\nend\nend\nfunction cs2005.schemaVersion(prj)\nlocal action = premake.action.current()\nif action.vstudio.csprojSchemaVersion then\n_p(2,'<SchemaVersion>%s</SchemaVersion>', action.vstudio.csprojSchemaVersion)\nend\nend\nfunction cs2005.targetFrameworkVersion(prj)\nlocal action = premake.action.current()\nlocal framework = prj.framework or action.vstudio.targetFramework\nif framework then\n_p(2,'<TargetFrameworkVersion>v%s</TargetFrameworkVersion>', framework)\nend\nend\nfunction cs2005.targetFrameworkProfile(prj)\nif _ACTION == \"vs2010\" then\n_p(2,'<TargetFrameworkProfile>')\n_p(2,'</TargetFrameworkProfile>')\nend\nend\nfunction cs2005.targets(prj)\nlocal bin = iif(_ACTION <= \"vs2010\", \"MSBuildBinPath\", \"MSBuildToolsPath\")\n_p(1,'<Import Project=\"$(%s)\\\\M"
	"icrosoft.CSharp.targets\" />', bin)\n_p(1,'<!-- To modify your build process, add your task inside one of the targets below and uncomment it.')\n_p(1,'     Other similar extension points exist, see Microsoft.Common.targets.')\n_p(1,'<Target Name=\"BeforeBuild\">')\n_p(1,'</Target>')\n_p(1,'<Target Name=\"AfterBuild\">')\n_p(1,'</Target>')\n_p(1,'-->')\nend\n",

	/* actions/vstudio/vs2005_csproj_user.lua */
	"local cs2005 = premake.vstudio.cs2005\nlocal project = premake.project\nfunction cs2005.generate_user(prj)\nio.indent = \"  \"\n_p('<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">')\n_p(1,'<PropertyGroup>')\nlocal cfg = project.getfirstconfig(prj)\nlocal refpaths = path.translate(project.getrelative(prj, cfg.libdirs))\n_p(2,'<ReferencePath>%s</ReferencePath>', table.concat(refpaths, \";\"))\n_p('  </PropertyGroup>')\n_p('</Project>')\nend\n",

	/* actions/vstudio/vs2010.lua */
	"premake.vstudio.vs2010 = {}\nlocal vs2010 = premake.vstudio.vs2010\nlocal vstudio = premake.vstudio\nfunction vs2010.esc(value)\nvalue = string.gsub(value, '&',  \"&amp;\")\nvalue = value:gsub('<',  \"&lt;\")\nvalue = value:gsub('>',  \"&gt;\")\nvalue = value:gsub('\\r', \"&#x0D;\")\nvalue = value:gsub('\\n', \"&#x0A;\")\nreturn value\nend\nfunction vs2010.generateProject(prj)\nio.eol = \"\\r\\n\"\nio.esc = vs2010.esc\nif premake.project.isdotnet(prj) then\npremake.generate(prj, \".csproj\", vstudio.cs2005.generate)\npremake.generate(prj, \".csproj.user\", vstudio.cs2005.generate_user)\nelse\npremake.generate(prj, \".vcxproj\", vstudio.vc2010.generate)\npremake.generate(prj, \".vcxproj.user\", vstudio.vc2010.generateUser)\npremake.generate(prj, \".vcxproj.filters\", vstudio.vc2010.generateFilters)\nend\nend\nnewaction {\ntrigger     = \"vs2010\",\nshortname   = \"Visual Studio 2010\",\ndescription = \"Generate Visual Studio 2010 project files\",\nos = \"windows\",\nvalid_kinds     = { \"ConsoleApp\", \"Windowe"
	"dApp\", \"StaticLib\", \"SharedLib\", \"Makefile\", \"None\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"msc\"   },\ndotnet = { \"msnet\" },\n},\nonsolution = vstudio.vs2005.generateSolution,\nonproject  = vstudio.vs2010.generateProject,\noncleansolution = vstudio.cleanSolution,\noncleanproject  = vstudio.cleanProject,\noncleantarget   = vstudio.cleanTarget,\nvstudio = {\ncsprojSchemaVersion = \"2.0\",\nproductVersion      = \"8.0.30703\",\nsolutionVersion     = \"11\",\ntargetFramework     = \"4.0\",\ntoolsVersion        = \"4.0\",\n}\n}\n",

	/* actions/vstudio/vs2010_vcxproj.lua */
	"premake.vstudio.vc2010 = {}\nlocal vc2010 = premake.vstudio.vc2010\nlocal vstudio = premake.vstudio\nlocal project = premake.project\nlocal config = premake.config\nlocal fileconfig = premake.fileconfig\nlocal tree = premake.tree\nvc2010.elements = {}\nfunction vc2010.generate(prj)\nio.indent = \"  \"\nio.utf8()\nvc2010.project(\"Build\")\nvc2010.projectConfigurations(prj)\nvc2010.globals(prj)\n_p(1,'<Import Project=\"$(VCTargetsPath)\\\\Microsoft.Cpp.Default.props\" />')\nfor cfg in project.eachconfig(prj) do\nvc2010.configurationProperties(cfg)\nend\n_p(1,'<Import Project=\"$(VCTargetsPath)\\\\Microsoft.Cpp.props\" />')\n_p(1,'<ImportGroup Label=\"ExtensionSettings\">')\n_p(1,'</ImportGroup>')\nfor cfg in project.eachconfig(prj) do\nvc2010.propertySheets(cfg)\nend\n_p(1,'<PropertyGroup Label=\"UserMacros\" />')\nfor cfg in project.eachconfig(prj) do\nvc2010.outputProperties(cfg)\nvc2010.nmakeProperties(cfg)\nend\nfor cfg in project.eachconfig(prj) do\nvc2010.itemDefinitionGroup(cfg)\nend\nvc2010.assemblyRefe"
	"rences(prj)\nvc2010.files(prj)\nvc2010.projectReferences(prj)\nvc2010.import(prj)\nio.printf('</Project>')\nend\nfunction vc2010.project(target)\n_p('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\nlocal defaultTargets = \"\"\nif target then\ndefaultTargets = string.format(' DefaultTargets=\"%s\"', target)\nend\n_p('<Project%s ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">', defaultTargets)\nend\nfunction vc2010.projectConfigurations(prj)\nlocal platforms = {}\nfor cfg in project.eachconfig(prj) do\nlocal arch = vstudio.archFromConfig(cfg, true)\nif not table.contains(platforms, arch) then\ntable.insert(platforms, arch)\nend\nend\nlocal configs = {}\n_p(1,'<ItemGroup Label=\"ProjectConfigurations\">')\nfor cfg in project.eachconfig(prj) do\nfor _, arch in ipairs(platforms) do\nlocal prjcfg = vstudio.projectConfig(cfg, arch)\nif not configs[prjcfg] then\nconfigs[prjcfg] = prjcfg\n_x(2,'<ProjectConfiguration Include=\"%s\">', vstudio.projectConfig(cfg, arch))\n_x(3,'<Configurat"
	"ion>%s</Configuration>', vstudio.projectPlatform(cfg))\n_p(3,'<Platform>%s</Platform>', arch)\n_p(2,'</ProjectConfiguration>')\nend\nend\nend\n_p(1,'</ItemGroup>')\nend\nfunction vc2010.targetFramework(prj)\nlocal framework = prj.framework or \"4.0\"\n_p(2,'<TargetFrameworkVersion>v%s</TargetFrameworkVersion>', framework)\nend\nfunction vc2010.globals(prj)\nvc2010.propertyGroup(nil, \"Globals\")\nvc2010.projectGuid(prj)\nlocal isWin, isManaged, isMakefile\nfor cfg in project.eachconfig(prj) do\nif cfg.system == premake.WINDOWS then\nisWin = true\nend\nif cfg.flags.Managed then\nisManaged = true\nend\nif vstudio.isMakefile(cfg) then\nisMakefile = true\nend\nend\nif isWin then\nif isMakefile then\n_p(2,'<Keyword>MakeFileProj</Keyword>')\nelse\nif isManaged then\nvc2010.targetFramework(prj)\n_p(2,'<Keyword>ManagedCProj</Keyword>')\nelse\n_p(2,'<Keyword>Win32Proj</Keyword>')\nend\n_p(2,'<RootNamespace>%s</RootNamespace>', prj.name)\nend\nend\nvc2010.projectName(prj)\n_p(1,'</PropertyGroup>')\nend\nvc2010.elements."
	"configurationProperties = {\n\"configurationType\",\n\"useDebugLibraries\",\n\"useOfMfc\",\n\"clrSupport\",\n\"characterSet\",\n\"wholeProgramOptimization\",\n\"nmakeOutDirs\",\n}\nfunction vc2010.configurationProperties(cfg)\nvc2010.propertyGroup(cfg, \"Configuration\")\npremake.callarray(vc2010, vc2010.elements.configurationProperties, cfg)\n_p(1,'</PropertyGroup>')\nend\nfunction vc2010.propertySheets(cfg)\n_p(1,'<ImportGroup Label=\"PropertySheets\" %s>', vc2010.condition(cfg))\n_p(2,'<Import Project=\"$(UserRootDir)\\\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists(\\'$(UserRootDir)\\\\Microsoft.Cpp.$(Platform).user.props\\')\" Label=\"LocalAppDataPlatform\" />')\n_p(1,'</ImportGroup>')\nend\nvc2010.elements.outputProperties = {\n\"propertyGroup\",\n\"linkIncremental\",\n\"ignoreImportLibrary\",\n\"outDir\",\n\"outputFile\",\n\"intDir\",\n\"targetName\",\n\"targetExt\",\n\"imageXexOutput\",\n\"generateManifest\",\n}\nfunction vc2010.outputProperties(cfg)\nif not vstudio.isMakefile(cfg) then\npr"
	"emake.callarray(vc2010, vc2010.elements.outputProperties, cfg)\n_p(1,'</PropertyGroup>')\nend\nend\nfunction vc2010.nmakeProperties(cfg)\nif vstudio.isMakefile(cfg) then\nvc2010.propertyGroup(cfg)\nvc2010.nmakeOutput(cfg)\nvc2010.nmakeCommandLine(cfg, cfg.buildcommands, \"Build\")\nvc2010.nmakeCommandLine(cfg, cfg.rebuildcommands, \"ReBuild\")\nvc2010.nmakeCommandLine(cfg, cfg.cleancommands, \"Clean\")\n_p(1,'</PropertyGroup>')\nend\nend\nvc2010.elements.itemDefinitionGroup = {\n\"clCompile\",\n\"resourceCompile\",\n\"link\",\n\"manifest\",\n\"buildEvents\",\n\"imageXex\",\n\"deploy\",\n}\nfunction vc2010.itemDefinitionGroup(cfg)\nif not vstudio.isMakefile(cfg) then\n_p(1,'<ItemDefinitionGroup %s>', vc2010.condition(cfg))\npremake.callarray(vc2010, vc2010.elements.itemDefinitionGroup, cfg)\n_p(1,'</ItemDefinitionGroup>')\nelse\nif cfg == project.getfirstconfig(cfg.project) then\n_p(1,'<ItemDefinitionGroup>')\n_p(1,'</ItemDefinitionGroup>')\nend\nend\nend\nvc2010.elements.clCompile = {\n\"precompiledHeader\",\n"
	"\"warningLevel\",\n\"treatWarningAsError\",\n\"basicRuntimeChecks\",\n\"clCompilePreprocessorDefinitions\",\n\"clCompileAdditionalIncludeDirectories\",\n\"clCompileAdditionalUsingDirectories\",\n\"forceIncludes\",\n\"debugInformationFormat\",\n\"programDataBaseFileName\",\n\"optimization\",\n\"functionLevelLinking\",\n\"intrinsicFunctions\",\n\"minimalRebuild\",\n\"omitFramePointers\",\n\"stringPooling\",\n\"runtimeLibrary\",\n\"exceptionHandling\",\n\"runtimeTypeInfo\",\n\"bufferSecurityCheck\",\n\"treatWChar_tAsBuiltInType\",\n\"floatingPointModel\",\n\"enableEnhancedInstructionSet\",\n\"multiProcessorCompilation\",\n\"additionalCompileOptions\",\n\"compileAs\",\n}\nfunction vc2010.clCompile(cfg)\n_p(2,'<ClCompile>')\npremake.callarray(vc2010, vc2010.elements.clCompile, cfg)\n_p(2,'</ClCompile>')\nend\nvc2010.elements.resourceCompile = {\n\"resourcePreprocessorDefinitions\",\n\"resourceAdditionalIncludeDirectories\",\n}\nfunction vc2010.resourceCompile(cfg)\nif cfg.system ~= premake.XBOX360 then\n_p(2,'<Reso"
	"urceCompile>')\npremake.callarray(vc2010, vc2010.elements.resourceCompile, cfg)\n_p(2,'</ResourceCompile>')\nend\nend\nfunction vc2010.link(cfg)\nlocal explicit = vstudio.needsExplicitLink(cfg)\n_p(2,'<Link>')\nvc2010.subSystem(cfg)\nvc2010.generateDebugInformation(cfg)\nvc2010.optimizeReferences(cfg)\nif cfg.kind ~= premake.STATICLIB then\nvc2010.linkDynamic(cfg, explicit)\nend\n_p(2,'</Link>')\nif cfg.kind == premake.STATICLIB then\nvc2010.linkStatic(cfg)\nend\nvc2010.linkLibraryDependencies(cfg, explicit)\nend\nfunction vc2010.linkDynamic(cfg, explicit)\nvc2010.additionalDependencies(cfg, explicit)\nvc2010.additionalLibraryDirectories(cfg)\nvc2010.importLibrary(cfg)\nvc2010.entryPointSymbol(cfg)\nvc2010.moduleDefinitionFile(cfg)\nvc2010.additionalLinkOptions(cfg)\nend\nfunction vc2010.linkStatic(cfg)\nif #cfg.linkoptions > 0 then\n_p(2,'<Lib>')\nvc2010.additionalLinkOptions(cfg)\n_p(2,'</Lib>')\nend\nend\nfunction vc2010.manifest(cfg)\nif cfg.kind == premake.STATICLIB then\nreturn\nend\nlocal manifests = {}"
	"\nfor _, fname in ipairs(cfg.files) do\nif path.getextension(fname) == \".manifest\" then\ntable.insert(manifests, project.getrelative(cfg.project, fname))\nend\nend\nif #manifests == 0 then\nreturn\nend\n_p(2,'<Manifest>')\nvc2010.element(3, \"AdditionalManifestFiles\", nil, \"%s %%(AdditionalManifestFiles)\", table.concat(manifests, \" \"))\n_p(2,'</Manifest>')\nend\nfunction vc2010.buildEvents(cfg)\nfunction write(group, list)\nif #list > 0 then\n_p(2,'<%s>', group)\n_x(3,'<Command>%s</Command>', table.implode(list, \"\", \"\", \"\\r\\n\"))\n_p(2,'</%s>', group)\nend\nend\nwrite(\"PreBuildEvent\", cfg.prebuildcommands)\nwrite(\"PreLinkEvent\", cfg.prelinkcommands)\nwrite(\"PostBuildEvent\", cfg.postbuildcommands)\nend\nfunction vc2010.assemblyReferences(prj)\nlocal cfg = project.getfirstconfig(prj)\nlocal refs = config.getlinks(cfg, \"system\", \"fullpath\", \"managed\")\n if #refs > 0 then\n _p(1,'<ItemGroup>')\n table.foreachi(refs, function(value)\nif value:find('/', 1, true) then\n_x(2,'<Reference Inclu"
	"de=\"%s\">', path.getbasename(value))\n_x(3,'<HintPath>%s</HintPath>', path.translate(value))\n_p(2,'</Reference>')\nelse\n_x(2,'<Reference Include=\"%s\" />', path.getbasename(value))\nend\n end)\n _p(1,'</ItemGroup>')\n end\nend\nfunction vc2010.files(prj)\nvc2010.simplefilesgroup(prj, \"ClInclude\")\nvc2010.compilerfilesgroup(prj)\nvc2010.simplefilesgroup(prj, \"None\")\nvc2010.simplefilesgroup(prj, \"ResourceCompile\")\nvc2010.customBuildFilesGroup(prj)\nend\nfunction vc2010.simplefilesgroup(prj, group)\nlocal files = vc2010.getfilegroup(prj, group)\nif #files > 0  then\n_p(1,'<ItemGroup>')\nfor _, file in ipairs(files) do\n_x(2,'<%s Include=\\\"%s\\\" />', group, path.translate(file.relpath))\nend\n_p(1,'</ItemGroup>')\nend\nend\nfunction vc2010.compilerfilesgroup(prj)\nlocal files = vc2010.getfilegroup(prj, \"ClCompile\")\nif #files > 0  then\n_p(1,'<ItemGroup>')\nfor _, file in ipairs(files) do\nlocal contents = io.capture(function ()\nfor cfg in project.eachconfig(prj) do\nlocal condition = vc2010.cond"
	"ition(cfg)\nlocal filecfg = fileconfig.getconfig(file, cfg)\nvc2010.excludedFromBuild(cfg, filecfg)\nif filecfg then\nvc2010.objectFileName(filecfg)\nvc2010.optimization(filecfg, condition)\nvc2010.forceIncludes(filecfg, condition)\nvc2010.precompiledHeader(cfg, filecfg, condition)\nvc2010.additionalCompileOptions(filecfg, condition)\nend\nend\nend)\nif #contents > 0 then\n_x(2,'<ClCompile Include=\\\"%s\\\">', path.translate(file.relpath))\n_p(\"%s\", contents)\n_p(2,'</ClCompile>')\nelse\n_x(2,'<ClCompile Include=\\\"%s\\\" />', path.translate(file.relpath))\nend\nend\n_p(1,'</ItemGroup>')\nend\nend\nfunction vc2010.customBuildFilesGroup(prj)\nlocal files = vc2010.getfilegroup(prj, \"CustomBuild\")\nif #files > 0  then\n_p(1,'<ItemGroup>')\nfor _, file in ipairs(files) do\n_x(2,'<CustomBuild Include=\\\"%s\\\">', path.translate(file.relpath))\n_p(3,'<FileType>Document</FileType>')\nfor cfg in project.eachconfig(prj) do\nlocal condition = vc2010.condition(cfg)\nlocal filecfg = fileconfig.getconfig(file, cfg)"
	"\nif fileconfig.hasCustomBuildRule(filecfg) then\nlocal commands = table.concat(filecfg.buildcommands,'\\r\\n')\n_p(3,'<Command %s>%s</Command>', condition, premake.esc(commands))\nlocal outputs = project.getrelative(prj, filecfg.buildoutputs)\nvc2010.element(3, \"Outputs\", condition, '%s', table.concat(outputs, \" \"))\nif filecfg.buildmessage then\nvc2010.element(3, \"Message\", condition, '%s', premake.esc(filecfg.buildmessage))\nend\nend\nend\n_p(2,'</CustomBuild>')\nend\n_p(1,'</ItemGroup>')\nend\nend\nfunction vc2010.getfilegroup(prj, group)\nlocal groups = prj.vc2010_file_groups\nif not groups then\ngroups = {\nClCompile = {},\nClInclude = {},\nNone = {},\nResourceCompile = {},\nCustomBuild = {},\n}\nprj.vc2010_file_groups = groups\nlocal tr = project.getsourcetree(prj)\ntree.traverse(tr, {\nonleaf = function(node)\nlocal hasbuildrule = false\nfor cfg in project.eachconfig(prj) do\nlocal filecfg = fileconfig.getconfig(node, cfg)\nif fileconfig.hasCustomBuildRule(filecfg) then\nhasbuildrule = true\nbrea"
	"k\nend\nend\nif hasbuildrule then\ntable.insert(groups.CustomBuild, node)\nelseif path.iscppfile(node.name) then\ntable.insert(groups.ClCompile, node)\nelseif path.iscppheader(node.name) then\ntable.insert(groups.ClInclude, node)\nelseif path.isresourcefile(node.name) then\ntable.insert(groups.ResourceCompile, node)\nelse\ntable.insert(groups.None, node)\nend\nend\n})\nend\nreturn groups[group]\nend\nfunction vc2010.projectReferences(prj)\nlocal deps = project.getdependencies(prj)\nif #deps > 0 then\n_p(1,'<ItemGroup>')\nfor _, dep in ipairs(deps) do\nlocal relpath = project.getrelative(prj, vstudio.projectfile(dep))\n_x(2,'<ProjectReference Include=\\\"%s\\\">', path.translate(relpath))\n_p(3,'<Project>{%s}</Project>', dep.uuid)\n_p(2,'</ProjectReference>')\nend\n_p(1,'</ItemGroup>')\nend\nend\nfunction vc2010.additionalDependencies(cfg, explicit)\nlocal links\nlocal toolset = premake.vstudio.vc200x.toolset(cfg)\nif toolset then\nlinks = toolset.getlinks(cfg, not explicit)\nelse\nlocal scope = iif(explicit, "
	"\"all\", \"system\")\nlinks = config.getlinks(cfg, scope, \"fullpath\")\nend\nif #links > 0 then\nlinks = path.translate(table.concat(links, \";\"))\n_x(3,'<AdditionalDependencies>%s;%%(AdditionalDependencies)</AdditionalDependencies>', links)\nend\nend\nfunction vc2010.additionalIncludeDirectories(cfg, includedirs)\nif #includedirs > 0 then\nlocal dirs = project.getrelative(cfg.project, includedirs)\ndirs = path.translate(table.concat(dirs, \";\"))\n_x(3,'<AdditionalIncludeDirectories>%s;%%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>', dirs)\nend\nend\nfunction vc2010.additionalLibraryDirectories(cfg)\nif #cfg.libdirs > 0 then\nlocal dirs = project.getrelative(cfg.project, cfg.libdirs)\ndirs = path.translate(table.concat(dirs, \";\"))\n_x(3,'<AdditionalLibraryDirectories>%s;%%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>', dirs)\nend\nend\nfunction vc2010.additionalUsingDirectories(cfg)\nif #cfg.usingdirs > 0 then\nlocal dirs = project.getrelative(cfg.project, cfg.usingdirs)\n"
	"dirs = path.translate(table.concat(dirs, \";\"))\n_x(3,'<AdditionalUsingDirectories>%s;%%(AdditionalUsingDirectories)</AdditionalUsingDirectories>', dirs)\nend\nend\nfunction vc2010.additionalCompileOptions(cfg, condition)\nif #cfg.buildoptions > 0 then\nlocal opts = table.concat(cfg.buildoptions, \" \")\nvc2010.element(3, \"AdditionalOptions\", condition, '%s %%(AdditionalOptions)', opts)\nend\nend\nfunction vc2010.additionalLinkOptions(cfg)\nif #cfg.linkoptions > 0 then\nlocal opts = table.concat(cfg.linkoptions, \" \")\n_x(3, '<AdditionalOptions>%s %%(AdditionalOptions)</AdditionalOptions>', opts)\nend\nend\nfunction vc2010.basicRuntimeChecks(cfg)\nif cfg.flags.NoRuntimeChecks then\n_p(3,'<BasicRuntimeChecks>Default</BasicRuntimeChecks>')\nend\nend\nfunction vc2010.characterSet(cfg)\nif not vstudio.isMakefile(cfg) then\n_p(2,'<CharacterSet>%s</CharacterSet>', iif(cfg.flags.Unicode, \"Unicode\", \"MultiByte\"))\nend\nend\nfunction vc2010.wholeProgramOptimization(cfg)\nif cfg.flags.LinkTimeOptimization then\n"
	"_p(2,'<WholeProgramOptimization>true</WholeProgramOptimization>')\nend\nend\nfunction vc2010.clCompileAdditionalIncludeDirectories(cfg)\nvc2010.additionalIncludeDirectories(cfg, cfg.includedirs)\nend\nfunction vc2010.clCompileAdditionalUsingDirectories(cfg)\nvc2010.additionalUsingDirectories(cfg, cfg.usingdirs)\nend\nfunction vc2010.clCompilePreprocessorDefinitions(cfg)\nvc2010.preprocessorDefinitions(cfg, cfg.defines, false)\nend\nfunction vc2010.clrSupport(cfg)\nif cfg.flags.Managed then\n_p(2,'<CLRSupport>true</CLRSupport>')\nend\nend\nfunction vc2010.compileAs(cfg)\nif cfg.project.language == \"C\" then\n_p(3,'<CompileAs>CompileAsC</CompileAs>')\nend\nend\nfunction vc2010.configurationType(cfg)\nlocal types = {\nSharedLib = \"DynamicLibrary\",\nStaticLib = \"StaticLibrary\",\nConsoleApp = \"Application\",\nWindowedApp = \"Application\",\nMakefile = \"Makefile\",\nNone = \"Makefile\",\n}\n_p(2,'<ConfigurationType>%s</ConfigurationType>', types[cfg.kind])\nend\nfunction vc2010.debugInformationFormat(cfg)\nlo"
	"cal value\nif cfg.flags.Symbols then\nif cfg.debugformat == \"c7\" then\nvalue = \"OldStyle\"\nelseif cfg.architecture == \"x64\" or\n       cfg.flags.Managed or\n   config.isOptimizedBuild(cfg) or\n   cfg.flags.NoEditAndContinue\nthen\nvalue = \"ProgramDatabase\"\nelse\nvalue = \"EditAndContinue\"\nend\nend\nif value then\n_p(3,'<DebugInformationFormat>%s</DebugInformationFormat>', value)\nend\nend\nfunction vc2010.deploy(cfg)\nif cfg.system == premake.XBOX360 then\n_p(2,'<Deploy>')\n_p(3,'<DeploymentType>CopyToHardDrive</DeploymentType>')\n_p(3,'<DvdEmulationType>ZeroSeekTimes</DvdEmulationType>')\n_p(3,'<DeploymentFiles>$(RemoteRoot)=$(ImagePath);</DeploymentFiles>')\n_p(2,'</Deploy>')\nend\nend\nfunction vc2010.enableEnhancedInstructionSet(cfg)\nlocal map = {\nSSE = \"StreamingSIMDExtensions\",\nSSE2 = \"StreamingSIMDExtensions2\"\n}\nlocal value = map[cfg.vectorextensions]\nif value then\n_p(3,'<EnableEnhancedInstructionSet>%s</EnableEnhancedInstructionSet>', value)\nend\nend\nfunction vc2010.entryPointSy"
	"mbol(cfg)\nif (cfg.kind == premake.CONSOLEAPP or cfg.kind == premake.WINDOWEDAPP) and\n   not cfg.flags.WinMain and\n   not cfg.flags.Managed and\n   cfg.system ~= premake.XBOX360\nthen\n_p(3,'<EntryPointSymbol>mainCRTStartup</EntryPointSymbol>')\nend\nend\nfunction vc2010.exceptionHandling(cfg)\nif cfg.flags.NoExceptions then\n_p(3,'<ExceptionHandling>false</ExceptionHandling>')\nelseif cfg.flags.SEH then\n_p(3,'<ExceptionHandling>Async</ExceptionHandling>')\nend\nend\nfunction vc2010.excludedFromBuild(cfg, filecfg)\nif not filecfg or filecfg.flags.ExcludeFromBuild then\n_p(3,'<ExcludedFromBuild %s>true</ExcludedFromBuild>', vc2010.condition(cfg))\nend\nend\nfunction vc2010.floatingPointModel(cfg)\nif cfg.floatingpoint then\n_p(3,'<FloatingPointModel>%s</FloatingPointModel>', cfg.floatingpoint)\nend\nend\nfunction vc2010.forceIncludes(cfg, condition)\nif #cfg.forceincludes > 0 then\nlocal includes = path.translate(project.getrelative(cfg.project, cfg.forceincludes))\nvc2010.element(3, \"ForcedIncludeFiles\", "
	"condition, table.concat(includes, ';'))\nend\nif #cfg.forceusings > 0 then\nlocal usings = path.translate(project.getrelative(cfg.project, cfg.forceusings))\n_x(3,'<ForcedUsingFiles>%s</ForcedUsingFiles>', table.concat(usings, ';'))\nend\nend\nfunction vc2010.functionLevelLinking(cfg)\nif config.isOptimizedBuild(cfg) then\n_p(3,'<FunctionLevelLinking>true</FunctionLevelLinking>')\nend\nend\nfunction vc2010.generateDebugInformation(cfg)\n_p(3,'<GenerateDebugInformation>%s</GenerateDebugInformation>', tostring(cfg.flags.Symbols ~= nil))\nend\nfunction vc2010.generateManifest(cfg)\nif cfg.flags.NoManifest then\n_p(2,'<GenerateManifest>false</GenerateManifest>')\nend\nend\nfunction vc2010.ignoreImportLibrary(cfg)\nif cfg.kind == premake.SHAREDLIB and cfg.flags.NoImportLib then\n_p(2,'<IgnoreImportLibrary>true</IgnoreImportLibrary>');\nend\nend\nfunction vc2010.imageXex(cfg)\nif cfg.system == premake.XBOX360 then\n_p(2,'<ImageXex>')\n_p(3,'<ConfigurationFile>')\n_p(3,'</ConfigurationFile>')\n_p(3,'<AdditionalSectio"
	"ns>')\n_p(3,'</AdditionalSections>')\n_p(2,'</ImageXex>')\nend\nend\nfunction vc2010.imageXexOutput(cfg)\nif cfg.system == premake.XBOX360 then\n_x(2,'<ImageXexOutput>$(OutDir)$(TargetName).xex</ImageXexOutput>')\nend\nend\nfunction vc2010.import(prj)\n_p(1,'<Import Project=\"$(VCTargetsPath)\\\\Microsoft.Cpp.targets\" />')\n_p(1,'<ImportGroup Label=\"ExtensionTargets\">')\n_p(1,'</ImportGroup>')\nend\nfunction vc2010.importLibrary(cfg)\nif cfg.kind == premake.SHAREDLIB then\n_x(3,'<ImportLibrary>%s</ImportLibrary>', path.translate(cfg.linktarget.relpath))\nend\nend\nfunction vc2010.intDir(cfg)\nlocal objdir = project.getrelative(cfg.project, cfg.objdir)\n_x(2,'<IntDir>%s\\\\</IntDir>', path.translate(objdir))\nend\nfunction vc2010.intrinsicFunctions(cfg)\nif config.isOptimizedBuild(cfg) then\n_p(3,'<IntrinsicFunctions>true</IntrinsicFunctions>')\nend\nend\nfunction vc2010.linkIncremental(cfg)\nif cfg.kind ~= premake.STATICLIB then\n_p(2,'<LinkIncremental>%s</LinkIncremental>', tostring(config.canLinkIncrement"
	"al(cfg)))\nend\nend\nfunction vc2010.linkLibraryDependencies(cfg, explicit)\nif explicit then\n_p(2,'<ProjectReference>')\n_p(3,'<LinkLibraryDependencies>false</LinkLibraryDependencies>')\n_p(2,'</ProjectReference>')\nend\nend\nfunction vc2010.minimalRebuild(cfg)\nif config.isOptimizedBuild(cfg) or\n   cfg.flags.NoMinimalRebuild or\n   cfg.flags.MultiProcessorCompile or\n   cfg.debugformat == premake.C7\nthen\n_p(3,'<MinimalRebuild>false</MinimalRebuild>')\nend\nend\nfunction vc2010.moduleDefinitionFile(cfg)\nlocal df = config.findfile(cfg, \".def\")\nif df then\n_p(3,'<ModuleDefinitionFile>%s</ModuleDefinitionFile>', df)\nend\nend\nfunction vc2010.multiProcessorCompilation(cfg)\nif cfg.flags.MultiProcessorCompile then\n_p(3,'<MultiProcessorCompilation>true</MultiProcessorCompilation>')\nend\nend\nfunction vc2010.nmakeCommandLine(cfg, commands, phase)\nif #commands > 0 then\ncommands = table.concat(premake.esc(commands), io.eol)\n_p(2, '<NMake%sCommandLine>%s</NMake%sCommandLine>', phase, commands, phase)\nend"
	"\nend\nfunction vc2010.nmakeOutDirs(cfg)\nif vstudio.isMakefile(cfg) then\nvc2010.outDir(cfg)\nvc2010.intDir(cfg)\nend\nend\nfunction vc2010.nmakeOutput(cfg)\n_p(2,'<NMakeOutput>$(OutDir)%s</NMakeOutput>', cfg.buildtarget.name)\nend\nfunction vc2010.objectFileName(filecfg)\nif filecfg.objname ~= filecfg.basename then\n_p(3,'<ObjectFileName %s>$(IntDir)\\\\%s.obj</ObjectFileName>', vc2010.condition(filecfg.config), filecfg.objname)\nend\nend\nfunction vc2010.omitFramePointers(cfg)\nif cfg.flags.NoFramePointer then\n_p(3,'<OmitFramePointers>true</OmitFramePointers>')\nend\nend\nfunction vc2010.optimizeReferences(cfg)\nif config.isOptimizedBuild(cfg) then\n_p(3,'<EnableCOMDATFolding>true</EnableCOMDATFolding>')\n_p(3,'<OptimizeReferences>true</OptimizeReferences>')\nend\nend\nfunction vc2010.optimization(cfg, condition)\nlocal map = { Off=\"Disabled\", On=\"Full\", Debug=\"Disabled\", Full=\"Full\", Size=\"MinSpace\", Speed=\"MaxSpeed\" }\nlocal value = map[cfg.optimize]\nif value or not condition then\nvc2010.el"
	"ement(3, 'Optimization', condition, value or \"Disabled\")\nend\nend\nfunction vc2010.outDir(cfg)\nlocal outdir = project.getrelative(cfg.project, cfg.buildtarget.directory)\n_x(2,'<OutDir>%s\\\\</OutDir>', path.translate(outdir))\nend\nfunction vc2010.outputFile(cfg)\nif cfg.system == premake.XBOX360 then\n_p(2,'<OutputFile>$(OutDir)%s</OutputFile>', cfg.buildtarget.name)\nend\nend\nfunction vc2010.precompiledHeader(cfg, filecfg, condition)\nif filecfg then\nif cfg.pchsource == filecfg.abspath and not cfg.flags.NoPCH then\nvc2010.element(3, 'PrecompiledHeader', condition, 'Create')\nelseif filecfg.flags.NoPCH then\nvc2010.element(3, 'PrecompiledHeader', condition, 'NotUsing')\nend\nelse\nif not cfg.flags.NoPCH and cfg.pchheader then\n_p(3,'<PrecompiledHeader>Use</PrecompiledHeader>')\n_x(3,'<PrecompiledHeaderFile>%s</PrecompiledHeaderFile>', cfg.pchheader)\nelse\n_p(3,'<PrecompiledHeader>NotUsing</PrecompiledHeader>')\nend\nend\nend\nfunction vc2010.preprocessorDefinitions(cfg, defines, escapeQuotes)\nif #def"
	"ines > 0 then\ndefines = table.concat(defines, \";\")\nif escapeQuotes then\ndefines = defines:gsub('\"', '\\\\\"')\nend\n_x(3,'<PreprocessorDefinitions>%s;%%(PreprocessorDefinitions)</PreprocessorDefinitions>', defines)\nend\nend\nfunction vc2010.programDataBaseFileName(cfg)\nif cfg.flags.Symbols and cfg.debugformat ~= \"c7\" then\nlocal filename = cfg.buildtarget.basename\n_p(3,'<ProgramDataBaseFileName>$(OutDir)%s.pdb</ProgramDataBaseFileName>', filename)\nend\nend\nfunction vc2010.projectGuid(prj)\n_p(2,'<ProjectGuid>{%s}</ProjectGuid>', prj.uuid)\nend\nfunction vc2010.projectName(prj)\nif prj.name ~= prj.filename then\n_x(2,'<ProjectName>%s</ProjectName>', prj.name)\nend\nend\nfunction vc2010.propertyGroup(cfg, label)\nlocal cond\nif cfg then\ncond = string.format(' %s', vc2010.condition(cfg))\nend\nif label then\nlabel = string.format(' Label=\"%s\"', label)\nend\n_p(1,'<PropertyGroup%s%s>', cond or \"\", label or \"\")\nend\nfunction vc2010.resourceAdditionalIncludeDirectories(cfg)\nvc2010.additionalInc"
	"ludeDirectories(cfg, table.join(cfg.includedirs, cfg.resincludedirs))\nend\nfunction vc2010.resourcePreprocessorDefinitions(cfg)\nvc2010.preprocessorDefinitions(cfg, table.join(cfg.defines, cfg.resdefines), true)\nend\nfunction vc2010.runtimeLibrary(cfg)\nlocal runtimes = {\nStaticDebug = \"MultiThreadedDebug\",\nStaticRelease = \"MultiThreaded\",\n}\nlocal runtime = runtimes[config.getruntime(cfg)]\nif runtime then\n_p(3,'<RuntimeLibrary>%s</RuntimeLibrary>', runtime)\nend\nend\nfunction vc2010.runtimeTypeInfo(cfg)\nif cfg.flags.NoRTTI and not cfg.flags.Managed then\n_p(3,'<RuntimeTypeInfo>false</RuntimeTypeInfo>')\nend\nend\nfunction vc2010.bufferSecurityCheck(cfg)\nif cfg.flags.NoBufferSecurityCheck then\n_p(3,'<BufferSecurityCheck>false</BufferSecurityCheck>')\nend\nend\nfunction vc2010.stringPooling(cfg)\nif config.isOptimizedBuild(cfg) then\n_p(3,'<StringPooling>true</StringPooling>')\nend\nend\nfunction vc2010.subSystem(cfg)\nif cfg.system ~= premake.XBOX360 then\nlocal subsystem = iif(cfg.kind == prema"
	"ke.CONSOLEAPP, \"Console\", \"Windows\")\n_p(3,'<SubSystem>%s</SubSystem>', subsystem)\nend\nend\nfunction vc2010.targetExt(cfg)\nlocal ext = cfg.buildtarget.extension\nif ext ~= \"\" then\n_x(2,'<TargetExt>%s</TargetExt>', ext)\nelse\n_p(2,'<TargetExt>')\n_p(2,'</TargetExt>')\nend\nend\nfunction vc2010.targetName(cfg)\n_x(2,'<TargetName>%s%s</TargetName>', cfg.buildtarget.prefix, cfg.buildtarget.basename)\nend\nfunction vc2010.treatWChar_tAsBuiltInType(cfg)\nlocal map = { On = \"true\", Off = \"false\" }\nlocal value = map[cfg.nativewchar]\nif value then\n_p(3,'<TreatWChar_tAsBuiltInType>%s</TreatWChar_tAsBuiltInType>', value)\nend\nend\nfunction vc2010.treatWarningAsError(cfg)\nif cfg.flags.FatalWarnings and cfg.warnings ~= \"Off\" then\n_p(3,'<TreatWarningAsError>true</TreatWarningAsError>')\nend\nend\nfunction vc2010.useDebugLibraries(cfg)\nlocal runtime = config.getruntime(cfg)\n_p(2,'<UseDebugLibraries>%s</UseDebugLibraries>', tostring(runtime:endswith(\"Debug\")))\nend\nfunction vc2010.useOfMfc(cfg)\nif"
	" cfg.flags.MFC then\n_p(2,'<UseOfMfc>%s</UseOfMfc>', iif(cfg.flags.StaticRuntime, \"Static\", \"Dynamic\"))\nend\nend\nfunction vc2010.warningLevel(cfg)\nlocal map = { Off = \"TurnOffAllWarnings\", Extra = \"Level4\" }\nvc2010.element(3, \"WarningLevel\", nil, \"%s\", map[cfg.warnings] or \"Level3\")\nend\nfunction vc2010.condition(cfg)\nreturn string.format('Condition=\"\\'$(Configuration)|$(Platform)\\'==\\'%s\\'\"', premake.esc(vstudio.projectConfig(cfg)))\nend\nfunction vc2010.element(depth, name, condition, value, ...)\nif select('#',...) == 0 then\nvalue = premake.esc(value)\nend\nlocal format\nif condition then\nformat = string.format('<%s %s>%s</%s>', name, condition, value, name)\nelse\nformat = string.format('<%s>%s</%s>', name, value, name)\nend\n_x(depth, format, ...)\nend\n",

	/* actions/vstudio/vs2010_vcxproj_user.lua */
	"local vstudio = premake.vstudio\nlocal vc2010 = premake.vstudio.vc2010\nlocal project = premake.project\nfunction vc2010.generateUser(prj)\nio.indent = \"  \"\nvc2010.project()\nfor cfg in project.eachconfig(prj) do\n_p(1,'<PropertyGroup %s>', vc2010.condition(cfg))\nvc2010.debugsettings(cfg)\n_p(1,'</PropertyGroup>')\nend\n_p('</Project>')\nend\nfunction vc2010.debugsettings(cfg)\nvc2010.localDebuggerCommand(cfg)\nvc2010.localDebuggerWorkingDirectory(cfg)\nvc2010.debuggerFlavor(cfg)\nvc2010.localDebuggerCommandArguments(cfg)\nvc2010.localDebuggerEnvironment(cfg)\nend\nfunction vc2010.debuggerFlavor(cfg)\nif cfg.debugdir or cfg.debugcommand then\n_p(2,'<DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>')\nend\nend\nfunction vc2010.localDebuggerCommand(cfg)\nif cfg.debugcommand then\nlocal dir = project.getrelative(cfg.project, cfg.debugcommand)\n_p(2,'<LocalDebuggerCommand>%s</LocalDebuggerCommand>', path.translate(dir))\nend\nend\nfunction vc2010.localDebuggerCommandArguments(cfg)\nif #cfg.debugargs > 0 th"
	"en\n_x(2,'<LocalDebuggerCommandArguments>%s</LocalDebuggerCommandArguments>', table.concat(cfg.debugargs, \" \"))\nend\nend\nfunction vc2010.localDebuggerWorkingDirectory(cfg)\nif cfg.debugdir then\nlocal dir = project.getrelative(cfg.project, cfg.debugdir)\n_x(2,'<LocalDebuggerWorkingDirectory>%s</LocalDebuggerWorkingDirectory>', path.translate(dir))\nend\nend\nfunction vc2010.localDebuggerEnvironment(cfg)\nif #cfg.debugenvs > 0 then\nlocal envs = table.concat(cfg.debugenvs, \"\\n\")\nif cfg.flags.DebugEnvsInherit then\nenvs = envs .. \"\\n$(LocalDebuggerEnvironment)\"\nend\n_p(2,'<LocalDebuggerEnvironment>%s</LocalDebuggerEnvironment>', envs)\nif cfg.flags.DebugEnvsDontMerge then\n_p(2,'<LocalDebuggerMergeEnvironment>false</LocalDebuggerMergeEnvironment>')\nend\nend\nend\n",

	/* actions/vstudio/vs2010_vcxproj_filters.lua */
	"local vc2010 = premake.vstudio.vc2010\nlocal project = premake.project\nlocal tree = premake.tree\nfunction vc2010.generateFilters(prj)\nio.indent = \"  \"\nvc2010.project()\nvc2010.filters_uniqueidentifiers(prj)\nvc2010.filters_filegroup(prj, \"None\")\nvc2010.filters_filegroup(prj, \"ClInclude\")\nvc2010.filters_filegroup(prj, \"ClCompile\")\nvc2010.filters_filegroup(prj, \"ResourceCompile\")\nvc2010.filters_filegroup(prj, \"CustomBuild\")\nio.printf('</Project>')\nend\nfunction vc2010.filters_uniqueidentifiers(prj)\nlocal opened = false\nlocal tr = project.getsourcetree(prj)\ntree.traverse(tr, {\nonbranch = function(node, depth)\nif not opened then\n_p(1,'<ItemGroup>')\nopened = true\nend\n_x(2, '<Filter Include=\"%s\">', path.translate(node.path))\n_p(3, '<UniqueIdentifier>{%s}</UniqueIdentifier>', os.uuid(node.path))\n_p(2, '</Filter>')\nend\n}, false)\nif opened then\n_p(1,'</ItemGroup>')\nend\nend\nfunction vc2010.filters_filegroup(prj, group)\nlocal files = vc2010.getfilegroup(prj, group)\nif #files > "
	"0 then\n_p(1,'<ItemGroup>')\nfor _, file in ipairs(files) do\nif file.parent.path then\n_p(2,'<%s Include=\\\"%s\\\">', group, path.translate(file.relpath))\n_p(3,'<Filter>%s</Filter>', path.translate(file.parent.path))\n_p(2,'</%s>', group)\nelse\n_p(2,'<%s Include=\\\"%s\\\" />', group, path.translate(file.relpath))\nend\nend\n_p(1,'</ItemGroup>')\nend\nend\n",

	/* actions/vstudio/vs2012.lua */
	"local vstudio = premake.vstudio\nlocal cs2005 = vstudio.cs2005\nlocal vc2010 = vstudio.vc2010\nnewaction {\ntrigger     = \"vs2012\",\nshortname   = \"Visual Studio 2012\",\ndescription = \"Generate Visual Studio 2012 project files\",\nos = \"windows\",\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\", \"Makefile\", \"None\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"msc\"   },\ndotnet = { \"msnet\" },\n},\nonsolution = vstudio.vs2005.generateSolution,\nonproject  = vstudio.vs2010.generateProject,\noncleansolution = vstudio.cleanSolution,\noncleanproject  = vstudio.cleanProject,\noncleantarget   = vstudio.cleanTarget,\nvstudio = {\nsolutionVersion = \"12\",\ntargetFramework = \"4.5\",\ntoolsVersion    = \"4.0\",\n}\n}\ntable.insertafter(vc2010.elements.configurationProperties, \"characterSet\", \"platformToolset\")\nfunction vc2010.platformToolset(cfg)\nif _ACTION > \"vs2010\" then\n_p(2,'<PlatformToolset>v110</PlatformToolset>')\nend"
	"\nend\ntable.insertafter(cs2005.elements.project, \"projectElement\", \"commonProperties\")\nfunction cs2005.commonProperties(prj)\nif _ACTION > \"vs2010\" then\n_p(1,'<Import Project=\"$(MSBuildExtensionsPath)\\\\$(MSBuildToolsVersion)\\\\Microsoft.Common.props\" Condition=\"Exists(\\'$(MSBuildExtensionsPath)\\\\$(MSBuildToolsVersion)\\\\Microsoft.Common.props\\')\" />')\nend\nend\n",

	/* actions/vstudio/vs2013.lua */
	"local vstudio = premake.vstudio\nlocal cs2005 = vstudio.cs2005\nlocal vc2010 = vstudio.vc2010\nnewaction {\ntrigger     = \"vs2013\",\nshortname   = \"Visual Studio 2013\",\ndescription = \"Generate Visual Studio 2013 project files\",\nos = \"windows\",\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\", \"Makefile\", \"None\" },\nvalid_languages = { \"C\", \"C++\", \"C#\" },\nvalid_tools     = {\ncc     = { \"msc\"   },\ndotnet = { \"msnet\" },\n},\nonsolution = vstudio.vs2005.generateSolution,\nonproject  = vstudio.vs2010.generateProject,\noncleansolution = vstudio.cleanSolution,\noncleanproject  = vstudio.cleanProject,\noncleantarget   = vstudio.cleanTarget,\nvstudio = {\nsolutionVersion = \"12\",\ntargetFramework = \"4.5\",\ntoolsVersion    = \"12.0\",\n}\n}\npremake.override(vc2010, \"platformToolset\", function(orig, cfg)\nif _ACTION > \"vs2012\" then\n_p(2,'<PlatformToolset>v120</PlatformToolset>')\nelse\norig(cfg)\nend\nend)\n",

	/* actions/clean/_clean.lua */
	"premake.clean = {}\nnewaction {\ntrigger     = \"clean\",\ndescription = \"Remove all binaries and generated files\",\nexecute = function()\nprint(\"** The clean action has not yet been ported\")\nend\n}\n",

	0
};
